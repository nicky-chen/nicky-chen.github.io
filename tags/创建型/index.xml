<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>创建型 on 南乡清水</title>
    <link>https://nicky-chen.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/</link>
    <description>Recent content in 创建型 on 南乡清水</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved - 2018</copyright>
    <lastBuildDate>Thu, 07 Jun 2018 11:18:15 +0800</lastBuildDate>
    
	<atom:link href="https://nicky-chen.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计模式之单例模式终极版【克隆-序列化-反射】</title>
      <link>https://nicky-chen.github.io/2018/06/07/singletion/</link>
      <pubDate>Thu, 07 Jun 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2018/06/07/singletion/</guid>
      <description>1 基本内容 1.1 概念 单例模式，是指在任何时候，该类只能被实例化一次，在任何时候，访问该类的对象，对象都是同一个。只要是程序员都会使用到，甚至都不能算是设计模式。但是在我们使用中也需要了解一下单例特性和使用场景
1.2 模式优缺点 单例模式有以下优点： &amp;gt;使用单例模式可以严格的控制用户怎样以及如何访问它 节约系统资源，提高系统的性能
单例模式有以下缺点： &amp;gt;不易扩展 单例类职责过重，在一定程度上违背了“单一职责原则” 如实例化对象长时间未使用，会GC回收，导致对象状态的丢失
# 2 单例模式分类
2.1 饿汉模式  public class SingletonEHan { private SingletonEHan() {} /** * 1.单例模式的饿汉式 */ private static SingletonEHan singletonEHan = new SingletonEHan(); public static SingletonEHan getInstance() { return singletonEHan; } // SingletonEHan instance= SingletonEHan.getInstance(); /** * 2. 单例模式的饿汉式变换写法 * 基本没区别 */ private static SingletonEHan singletonEHanTwo = null; static { singletonEHanTwo = new SingletonEHan(); } public static SingletonEHan getSingletonEHan() { if (singletonEHanTwo == null) { singletonEHanTwo = new SingletonEHan(); } return singletonEHanTwo; } // SingletonEHan instance= SingletonEHan.</description>
    </item>
    
    <item>
      <title>设计模式之builder模式</title>
      <link>https://nicky-chen.github.io/2017/12/19/builder/</link>
      <pubDate>Tue, 19 Dec 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2017/12/19/builder/</guid>
      <description>建造者模式也叫生成器模式，和抽象工厂模式相似，也是一种构建复杂对象的模式。
建造者模式中的角色分类：  抽象建造者Builder：接口类型，用于规范各个产品的组成部分；  具体建造者ConcreteBuilder：实现Builder中的所有方法，返回一个产品实例；  指导者Director：指挥建造者制造相应的产品  产品Product：用户最终看到的复杂对象。
假设我们有一个向客户发送新年祝福邮件的需求，而邮件内容可以是纯文档的，也可以是有动画的，也可以是有音频的，可以动态的添加个组件
uml下图所示： 如上图所示，邮箱有多个组件，包含收件人，发送人，内容，音乐等 通过具体的建造者添加不同的组件模版，最后通过指挥者去调用抽象建造者 来返回具体的email对象
代码如下 ==================product======================
public interface Module { String showInfo(String info); }` public abstract class CommonModule implements Module { protected String moduleName; protected String productionTime() { return Optional.ofNullable(moduleName).orElse(&amp;quot;&amp;quot;) + &amp;quot;--&amp;gt; createTime : &amp;quot; + LocalDate.now().toString(); } } public class Sender extends CommonModule{ public Sender() { super.moduleName = &amp;quot;发件人&amp;quot;; } @Override public String showInfo(String info) { return Optional.ofNullable(info).orElse(&amp;quot;sender : nicky@qq.</description>
    </item>
    
    <item>
      <title>设计模式之factory模式</title>
      <link>https://nicky-chen.github.io/2017/12/07/builder-factory/</link>
      <pubDate>Thu, 07 Dec 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2017/12/07/builder-factory/</guid>
      <description>定义：工厂模式通俗意义上讲就是一个多产品的流程化工厂，每个工厂生产同一系列相关性的组件
分类：
按工厂职能划分可以分为三类：  简单工厂模式（Simple Factory）  工厂方法模式（Factory Method）  抽象工厂方法（Abstract Factory）
接下来我们直接通过uml图和具体的代码实现以上三类
我们以汽车工厂生产汽车为例，本田工厂假设要生产CIVIC和CRV两种车型，那么我们该怎么去设计实现
1 简单工厂模式
工厂产品线流程如上图所示：工厂生产汽车通过指定汽车的编号，我们就可以走指定的产品线；调用者只需要选择具体车型而不需要内部车是怎么制造出来的
简单工厂模式主要包括三部分： 工厂角色：上图中的HONDAFactroy 生产车型用 抽象产品角色：上图中的HONDA和HONDACar 包含通用的属性和方法 具体产品角色：上图中的CIVIC和CRV，具体的车型包含各种参数
代码如下
/** * @author nicky_chin [shuilianpiying@163.com] * @since –created on 2017/12/27 at 11:11 */ public class CIVIC extends HONDACar implements HONDA { private String carName; private Double price; public CIVIC() { this.carName = &amp;quot;10代思域&amp;quot;; this.price = 158000.9; } @Override public String introduceCar() { return &amp;quot;CIVIC{&amp;quot; + &amp;quot;carName=&#39;&amp;quot; + carName + &#39;\&#39;&#39; + &amp;quot;, price=&amp;quot; + price + &amp;quot;} &amp;quot; + super.</description>
    </item>
    
  </channel>
</rss>