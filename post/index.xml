<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 南乡清水</title>
    <link>https://nicky-chin.cn/post/</link>
    <description>Recent content in Posts on 南乡清水</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved - 2018</copyright>
    <lastBuildDate>Tue, 19 May 2020 13:39:15 +0800</lastBuildDate>
    
	<atom:link href="https://nicky-chin.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Transaction源码解析之事务提交与回滚</title>
      <link>https://nicky-chin.cn/2020/05/19/spring-transaction-commit/</link>
      <pubDate>Tue, 19 May 2020 13:39:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2020/05/19/spring-transaction-commit/</guid>
      <description>1 事务还原 1.1 调试demo 我们使用常用的业务代码来做调试：
@Service(&amp;quot;personService&amp;quot;) public class PersonServiceImpl implements IPersonService { @Override @Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, rollbackFor = Exception.class) public void removeUserById(Integer id) { personRepository.removeById(id); User user = new User(); user.setId(0); user.setName(&amp;quot;aaa&amp;quot;); user.setSumScore(&amp;quot;222&amp;quot;); user.setAvgScore(&amp;quot;111&amp;quot;); user.setAge(20); user.setIsSuccess(false); user.setScore(UnsignedInteger.valueOf(1)); user.setStatus(UnsignedLong.valueOf(2)); userService.insertOne(user); } } @Repository public interface PersonRepository extends JpaRepository&amp;lt;Person, Integer&amp;gt;, JpaSpecificationExecutor { Person findByName(String name); @Query(&amp;quot;select p from Person p where p.id = ?1&amp;quot;) Person findObjectById(Integer id); //@CacheEvict(value = &amp;quot;person&amp;quot;) @Transactional(propagation = Propagation.</description>
    </item>
    
    <item>
      <title>Transaction源码解析之事务预处理</title>
      <link>https://nicky-chin.cn/2020/05/11/spring-transaction-prepare/</link>
      <pubDate>Mon, 11 May 2020 12:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2020/05/11/spring-transaction-prepare/</guid>
      <description>1 调试源码 接上篇Transaction源码解析之事务的配置解析
我们调用相应的service类,来调试具体的事务处理流程，测试代码如下:
public void testInvokeTransactional() throws Exception { TransactionalTestBean testBean = getTestBean(); CallCountingTransactionManager ptm = (CallCountingTransactionManager) context.getBean(&amp;quot;transactionManager&amp;quot;); // try with transactional assertEquals(&amp;quot;Should not have any started transactions&amp;quot;, 0, ptm.begun); testBean.findAllFoos(); assertEquals(&amp;quot;Should have 1 started transaction&amp;quot;, 1, ptm.begun); assertEquals(&amp;quot;Should have 1 committed transaction&amp;quot;, 1, ptm.commits); // try with non-transaction testBean.doSomething(); assertEquals(&amp;quot;Should not have started another transaction&amp;quot;, 1, ptm.begun); // try with exceptional try { testBean.exceptional(new IllegalArgumentException(&amp;quot;foo&amp;quot;)); fail(&amp;quot;Should NEVER get here&amp;quot;); } catch (Throwable throwable) { assertEquals(&amp;quot;Should have another started transaction&amp;quot;, 2, ptm.</description>
    </item>
    
    <item>
      <title>Transaction源码解析之事务配置解析</title>
      <link>https://nicky-chin.cn/2020/05/03/spring-transaction-config/</link>
      <pubDate>Sun, 03 May 2020 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2020/05/03/spring-transaction-config/</guid>
      <description>1 事务配置 关于Spring的事务，大家每天都会遇见或者用到，为了更好的理解Transaction的原理机制，我们从源码角度来解析，本文的调试源码基于Spring-3.2.x版本进行调试。
1.1 配置 配置XML文件annotationTransactionNamespaceHandlerTests.xml
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot; xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot; xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd&amp;quot;&amp;gt; &amp;lt;tx:annotation-driven/&amp;gt; &amp;lt;bean id=&amp;quot;transactionManager&amp;quot; class=&amp;quot;org.springframework.tests.transaction.CallCountingTransactionManager&amp;quot;/&amp;gt; &amp;lt;bean id=&amp;quot;testBean&amp;quot; class=&amp;quot;org.springframework.transaction.annotation.AnnotationTransactionNamespaceHandlerTests$TransactionalTestBean&amp;quot;/&amp;gt; &amp;lt;context:mbean-export/&amp;gt;  TransactionalTestBean类
	@Service @ManagedResource(&amp;quot;test:type=TestBean&amp;quot;) public static class TransactionalTestBean { @Transactional(readOnly = true) public Collection&amp;lt;?&amp;gt; findAllFoos() { return null; } public void saveFoo() { } @Transactional(&amp;quot;qualifiedTransactionManager&amp;quot;) public void saveQualifiedFoo() { } @Transactional public void exceptional(Throwable t) throws Throwable { throw t; } @ManagedOperation public String doSomething() { return &amp;quot;done&amp;quot;; } @Transactional protected void annotationsOnProtectedAreIgnored() { } }  上面XML配置主要是开启事务驱动，然后配置事务管理器和带有@Transaction注解的Bean对象</description>
    </item>
    
    <item>
      <title>生产-消费模型之虚假唤醒</title>
      <link>https://nicky-chin.cn/2020/04/23/spurious-wakeup/</link>
      <pubDate>Thu, 23 Apr 2020 19:58:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2020/04/23/spurious-wakeup/</guid>
      <description>1 何为虚假唤醒 当线程从等待状态中被唤醒时，只是发现未满足其正在等待的条件时，就会发生虚假唤醒。 之所以称其为虚假的，是因为该线程似乎无缘无故被唤醒。 虚假唤醒不会无缘无故发生，通常是因为在发起唤醒号和等待线程最终运行之间的临界时间内，线程不再满足竞态条件。
2 java中的例子  public class SpuriousWakeupRWLock { private static final CustomQueue CUSTOM_LIST = new CustomQueue(); public static void main(String[] args) throws Exception { for (int i = 0; i &amp;lt; 8; i++) { Thread consumer = new Thread(() -&amp;gt; { try { CUSTOM_LIST.getOne(); } catch (InterruptedException e) { e.printStackTrace(); } ; }); consumer.setName(&amp;quot;consumer:[&amp;quot; + i + &amp;quot;]&amp;quot;); consumer.start(); } TimeUnit.SECONDS.sleep(8); for (int i = 0; i &amp;lt; 2 ; i++) { int finalI = i; Thread producer = new Thread(() -&amp;gt; { try { CUSTOM_LIST.</description>
    </item>
    
    <item>
      <title>Spring实例化bean之源码分析</title>
      <link>https://nicky-chin.cn/2020/04/15/spring-bean-instantiation/</link>
      <pubDate>Wed, 15 Apr 2020 13:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2020/04/15/spring-bean-instantiation/</guid>
      <description>1 实例化bean的主流程 这张图是整体的bean的实例化的流程，我之前关于Spring的生命周期的加载bean和实例化bean的整体过程已有博文，可以 查看文章：Spring之Bean加载-解析-生命周期
调试入口 本文中的Spring源码基于3.2.x版本，为最精简的Spring源码，选取Spring自带的测试用例进行debug调试, 本文只关注单例对象的实例化bean中各组件的源码分析, 入口如下：
 @Test public void testConfigLocationPattern() { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(CONTEXT_WILDCARD); assertTrue(ctx.containsBean(&amp;quot;service&amp;quot;)); assertTrue(ctx.containsBean(&amp;quot;logicOne&amp;quot;)); assertTrue(ctx.containsBean(&amp;quot;logicTwo&amp;quot;)); Service service = (Service) ctx.getBean(&amp;quot;service&amp;quot;); ctx.close(); assertTrue(service.isProperlyDestroyed()); }  2 各组件流程 实例化bean的流程主要关注AbstractAutowireCapableBeanFactory的doCreateBean方法，源码如下：
2.1 整体流程解析  protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) { // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装bean的属性描述器 BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { // 单例模型，则从未完成的 FactoryBean 缓存中删除 instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } // 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化 if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } // 包装的实例对象 final Object bean = (instanceWrapper !</description>
    </item>
    
    <item>
      <title>float浮点小数的设计及精度问题</title>
      <link>https://nicky-chin.cn/2020/03/02/float-precision/</link>
      <pubDate>Mon, 02 Mar 2020 14:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2020/03/02/float-precision/</guid>
      <description>1 浮点计算问题  public class Oct2Bin { public static void main(String[] args) { double a = 0.1d; double b = 0.2d; System.out.println(a + b); } }   结果为0.30000000000000004，而非0.3
 2 小数计算丢精度原因 2.1 十进制小数转换为二进制小数方法 十进制小数转换成二进制小数采用&amp;rdquo;乘2取整，顺序排列&amp;rdquo;法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。 然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。
2.2 、0.3背后丢精度的原因  0.3 x 2 = 0.6 ------取整数部分 0 0.6 x 2 = 1.2 ------取整数部分 1 0.2 x 2 = 0.4 ------取整数部分 0 0.4 x 2 = 0.8 ------取整数部分 0 0.8 x 2 = 1.</description>
    </item>
    
    <item>
      <title>MySQL中的page页详解</title>
      <link>https://nicky-chin.cn/2019/07/11/mysql-page-detail/</link>
      <pubDate>Thu, 11 Jul 2019 11:14:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2019/07/11/mysql-page-detail/</guid>
      <description>1 InnoDB中的存储结构 从InnoDB存储引擎的逻辑结构看，所有数据都被逻辑地存放在一个空间内，称为表空间(tablespace)，而表空间由段（sengment）、区（extent）、页（page）组成。 在一些文档中extend又称块（block）。
1.1 表空间（table space） 表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。
在 InnoDB 中存在两种表空间的类型：共享表空间和独立表空间。如果是共享表空间就意味着多张表共用一个表空间。如果是独立表空间，就意味着每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间可以在不同的数据库之间进行迁移。可通过命令
mysql &amp;gt; show variables like &#39;innodb_file_per_table&#39;;  查看当前系统启用的表空间类型。目前最新版本已经默认启用独立表空间。
InnoDB把数据保存在表空间内，表空间可以看作是InnoDB存储引擎逻辑结构的最高层。本质上是一个由一个或多个磁盘文件组成的虚拟文件系统。InnoDB用表空间并不只是存储表和索引，还保存了回滚段、双写缓冲区等。
1.2 段（segment） 段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64 个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。
1.3 区块（extent） 在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB=1MB。在任何情况下每个区大小都为1MB，为了保证页的连续性，InnoDB存储引擎每次从磁盘一次申请4-5个区。默认情况下，InnoDB存储引擎的页大小为16KB，即一个区中有64个连续的页。
1.4 页（Page） 页是InnoDB存储引擎磁盘管理的最小单位，每个页默认16KB；InnoDB存储引擎从1.2.x版本碍事，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为innodb_page_size，不可以再次对其进行修改，除非通过mysqldump导入和导出操作来产生新的库。
innoDB存储引擎中，常见的页类型有：
  数据页（B-tree Node)
 undo页（undo Log Page）
 系统页 （System Page）
 事物数据页 （Transaction System Page）
 插入缓冲位图页（Insert Buffer Bitmap）
 插入缓冲空闲列表页（Insert Buffer Free List）
 未压缩的二进制大对象页（Uncompressed BLOB Page）</description>
    </item>
    
    <item>
      <title>基于APT(注解处理器)实现Lombok的@getter @setter @toString功能</title>
      <link>https://nicky-chin.cn/2019/05/03/apt_lombok_implement/</link>
      <pubDate>Fri, 03 May 2019 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2019/05/03/apt_lombok_implement/</guid>
      <description>1 Lombok原理  1 APT(Annotation Processing Tool )注解处理器 2 javac api处理AST(抽象语法树)
 大致原理如下图所示：
上面是网上找的图，如想具体分析lombok的实现，可以从 LombokProcessor 和AnnotationProcessor 这两个类的process 方法入手
2 自己实现Lombok 2.1 创建Data注解 @Documented @Retention(RetentionPolicy.SOURCE) @Target({ElementType.TYPE}) public @interface Data { }  该Data注解只能在编译期的时候获取到，在运行期是无法获取到的
2.2 自定义注解处理器 通过实现Processor接口可以自定义注解处理器，这里我们采用更简单的方法通过继承AbstractProcessor类实现自定义注解处理器。实现抽象方法process处理我们想要的功能
2.2.1 APT简单介绍 @SupportedAnnotationTypes({&amp;quot;com.nicky.lombok.annotation.Data&amp;quot;}) @SupportedSourceVersion(SourceVersion.RELEASE_8) public class DataProcessor extends AbstractProcessor { @Override public synchronized void init(ProcessingEnvironment processingEnv) { } @Override public boolean process(Set&amp;lt;? extends TypeElement&amp;gt; annotations, RoundEnvironment roundEnv) { } }  @SupportedAnnotationTypes 注解表示哪些注解需要注解处理器处理，可以多个注解校验 @SupportedSourceVersion 注解 用于指定jdk使用版本</description>
    </item>
    
    <item>
      <title>实际项目运用之Filter模式（过滤器模式）</title>
      <link>https://nicky-chin.cn/2019/02/15/filter/</link>
      <pubDate>Fri, 15 Feb 2019 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2019/02/15/filter/</guid>
      <description>1 模式简介 1.1 定义 过滤器模式（Filter）也叫条件模式（Criteria），这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。当我们想要选择满足一个或多个条件的对象子集时，此设计模式非常有用。它属于结构模式。
1.2 优点  它提供了一种根据特定条件过滤对象的方法
我们可以随时添加新过滤器，而不会影响客户端的代码
我们可以在程序执行期间动态选择过滤器
 1.3 过滤器设计 角色
 过滤器（Filter） - 过滤器在请求处理程序执行请求之前或之后，执行某些任务 过滤器链（Filter Chain） - 过滤器链带有多个过滤器 过滤对象 （Target）- 需要过滤的数据源对象 过滤管理器（Filter Manager） - 过滤管理器管理过滤器和过滤器链 客户端（Client） - Client 是向 Target 对象发送请求的对象  代码演示
Filter
public interface Filter { public void execute(String request); }  AuthenticationFilter
 public class AuthenticationFilter implements Filter { public void execute(String request){ System.out.println(&amp;quot;Authenticating request: &amp;quot; + request); } }  FilterChain</description>
    </item>
    
    <item>
      <title>实际项目运用之State模式（状态模式）</title>
      <link>https://nicky-chin.cn/2018/12/19/state-machine/</link>
      <pubDate>Wed, 19 Dec 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/12/19/state-machine/</guid>
      <description>1 模式简介 定义： 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。这个模式将状态封装成独立的类，并将动作委托到代表当前状态的类的对象
状态模式的优点： &amp;gt;封装了转换规则 枚举可能的状态，在枚举状态之前需要确定状态种类 将所有与某个状态有关的行为放到一个类中，可方便增加新的状态 允许状态转换逻辑与状态对象合成一体，而非复杂条件语句块 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数
状态模式的缺点： &amp;gt;增加系统类和对象的个数 结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱 对&amp;rdquo;开闭原则&amp;rdquo;的支持不太好，增加新状态类需在状态类上增加行为方法
状态模式的适用场景： 1. 对象的行为依赖于它的状态，并且可以在运行时根据状态改变行为。 2. 代码中包含大量与对象状态有关的if/else语句 3. 接口幂等要求
状态模式和策略模式： 相同点是它们都需要根据需求选择相应的状态或策略 不同点是状态模式是在一个类中通过不同的动作切换不同的状态，而策略模式是为一个类选择某个策略，即状态模式中的Context是和多个状态关联的，而策略模式中的Context只和一个策略关联
状态模式角色介绍： （1）Context类，依赖倒置原则，通过适配器模式维护状态类 （2）State：抽象状态类或状态接口，用以抽象封装行为 （3）ConcreteState类：具体状态类，实现了State中的抽象方法
2 实际运用 借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的状态，通常通过if/else判断订单的状态，从而实现不同的逻辑，伪代码如下：
if(审核){ //审核逻辑 }elseif(发布){ //发布逻辑 }elseif(接单){ //接单逻辑 }  上述解决方案缺点非常明显：这类代码难以应对变化，在添加一种状态时，我们需要手动添加if/else，在添加一种功能时，要对所有的状态进行判断。因此代码会变得越来越臃肿，并且一旦没有处理某个状态，便会发生极其严重的BUG，难以维护
2.1 状态模式应用 状态模式本质上是一种基于状态和事件的 状态机 ,下面是订单流程的状态图
通过状态图，我们再设计一张横纵坐标关系表来比较，图如下：
通过上述表 我们可以细化为一个二维数组，来表示状态与事件直接的关系：
2.2 代码实现 我们通过状态的各种图例分析来用代码实现逻辑
状态枚举类
public enum StateEnum { //订单生成 GENERATE(1, &amp;quot;GENERATE&amp;quot;), //已审核 REVIEWED(2, &amp;quot;REVIEWED&amp;quot;), //已发布 PUBLISHED(3, &amp;quot;PUBLISHED&amp;quot;), //待付款 NOT_PAY(4, &amp;quot;NOT_PAY&amp;quot;), //已付款 PAID(5, &amp;quot;PAID&amp;quot;), //已完结 FEED_BACKED(6, &amp;quot;FEED_BACKED&amp;quot;); private int key; private String value; StateEnum(int key, String value) { this.</description>
    </item>
    
    <item>
      <title>数据结构之BTree和B&#43;Tree(多路平衡查找树 )</title>
      <link>https://nicky-chin.cn/2018/11/17/btree-info/</link>
      <pubDate>Sat, 17 Nov 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/11/17/btree-info/</guid>
      <description>1 背景 B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。 InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：
mysql&amp;gt; show variables like &#39;innodb_page_size&#39;;  而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
2 定义与特性 B-Tree B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值(关键字)，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。
一棵m阶的B-Tree有如下特性： 1. 每个节点最多有m个孩子。 2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 3. 若根节点不是叶子节点，则至少有2个孩子 4. 所有叶子节点都在同一层，且不包含其它关键字信息 5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 6. 关键字的个数n满足：ceil(m/2)-1 &amp;lt;= n &amp;lt;= m-1 7. ki(i=1,…n)为关键字，且关键字升序排序。 8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)  B树中的每个节点根据实际情况可以包含大量的关键字信息和分支 如下图所示为一个3阶的B-Tree：
每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围大于35
模拟查找关键字29的过程： &amp;gt;根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】 比较关键字29在区间（17,35），找到磁盘块1的指针P2。 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】 比较关键字29在区间（26,30），找到磁盘块3的指针P2。 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】 在磁盘块8中的关键字列表中找到关键字29。 分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。
B+Tree
B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。
从B-Tree图可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
B+Tree相对于B-Tree有几点不同： 非叶子节点只存储键值信息。 所有叶子节点之间都有一个链指针。 数据记录都存放在叶子节点中。  将B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示:
通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。
可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：
InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3,计算可得深度为3的树可以存储10亿数量级数据
实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作
B+Tree索引可以分为聚集索引（clustered index）和非聚簇索引（secondary index）。上面B+Tree示例图在数据库中的实现即为聚集索引
聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。非聚簇索引与聚集索引的区别在于非聚簇索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过非聚簇索引来查询数据时，InnoDB存储引擎会遍历非聚簇索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据
# 3 B树 3.</description>
    </item>
    
    <item>
      <title>分布式全局序列ID方案之Redis优化方案</title>
      <link>https://nicky-chin.cn/2018/10/15/id-redis/</link>
      <pubDate>Mon, 15 Oct 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/10/15/id-redis/</guid>
      <description>1 Redis的Flicker方案 利用redis的lua脚本功能，在每个节点上通过lua脚本生成唯一ID，生成的ID为64位，具体如下：
使用41 bit来存放时间，精确到毫秒，可以使用到2039年 使用12 bit来存放逻辑分片ID，最大分片ID是4095 使用10 bit来存放自增长ID，则每个节点，每毫秒最多可生成1024个ID 比如GTM时间 2018年6月24日11点23分 ，它的距1970年的毫秒数是 1529810591000，假定分片ID是60，自增长序列是20，则生成的ID是：
6416490681073670164 = 1529810591000 &amp;lt;&amp;lt; 22 | 60 &amp;lt;&amp;lt; 10 | 20 redis提供了TIME命令，取得redis服务器的秒值和微秒值 毫秒值获取命令：EVAL &amp;quot;local current = redis.call(&#39;TIME&#39;) ;return a[1]*1000 + a[2]/1000&amp;quot; 0 生成最终ID : current &amp;lt;&amp;lt; (12 + 10)) | (shardingId &amp;lt;&amp;lt; 10) | seq  2 ID原子性自增方案 2.1 Redis HINCRBY 命令 Redis 的 INCR 命令支持 “INCR AND GET” 原子操作。利用这个特性，我们可以在 Redis 中存序列号，让分布式环境中多个取号服务在 Redis 中通过 INCR 命令来实现取号；同时 Redis 是单进程单线程架构，不会因为多个取号方的 INCR 命令导致取号重复。因此，基于 Redis 的 INCR 命令实现序列号的生成基本能满足全局唯一与单调递增的特性，并且性能还不错。</description>
    </item>
    
    <item>
      <title>分布式全局序列ID方案之Flicker优化方案</title>
      <link>https://nicky-chin.cn/2018/09/25/id-flicker/</link>
      <pubDate>Tue, 25 Sep 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/09/25/id-flicker/</guid>
      <description>1 Flicker的解决方案 MySQL中id自增的特性，可以借此来生成全局的序列号，Flicker在解决全局ID生成方案里就采用了MySQL自增长ID的机制（auto_increment + replace into + MyISAM）。一个生成64位ID方案具体就是这样的： 先创建单独的数据库，然后创建一个表：
CREATE TABLE borrow_order ( id bigint(20) unsigned NOT NULL auto_increment, stub char(1) NOT NULL default &#39;&#39;, PRIMARY KEY (id), UNIQUE KEY stub (stub) ) ENGINE=MyISAM  当我们插入记录后，执行SELECT * from borrow_order ，查询结果就是这样的：
+-------------------+------+ | id | stub | +-------------------+------+ | 1 | 192.168.100.102 | +-------------------+------+  在我们的应用端需要做下面这两个操作，在一个事务会话里提交：
REPLACE INTO borrow_order (stub) VALUES (&#39;192.168.100.102&#39;); SELECT LAST_INSERT_ID();  上述操作，通过 replace into 操作，首先尝试插入数据到表中，如果发现表中已经有此行数据则先删除此行数据，然后插入新的数据。 如果没有此行数据的话，直接插入新数据。注意：插入的行字段需要有主键索引或者唯一索引，否则会出错</description>
    </item>
    
    <item>
      <title>分布式全局序列ID方案之Snowflake算法</title>
      <link>https://nicky-chin.cn/2018/09/19/id-snowflake/</link>
      <pubDate>Wed, 19 Sep 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/09/19/id-snowflake/</guid>
      <description>1 背景 在分布式项目中，在业务数据中需要生成一个全局唯一的序列号，比如：消息标识，订单标识，用户标识等等。同时对于id生成的要求如下： * 全局唯一 * 趋势有序 * 主键索引 方便排序 * 高可用 * 高并发
2 基础方案 2.1 数据库主键自增 利用mysql的auto_increment特性 &amp;gt;优点： （1）能够保证唯一性 （2）能够保证递增性 （3）步长固定
 缺点： （1）无法高可用：普通的一主多从+读写分离架构，自增ID写入请求，主库挂了就GG （2）无法高并发：写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展
 2.2 UUID uuid算法是比较常用的算法，根据UUID的特性，可以产生一个唯一的字符串
 优点： （1）本地生成ID，无需远程服务调用，低延时 （2）扩展性好，基本可以-认为没有性能上限
缺点： （1）无法保证趋势递增 （2）uuid字符串过长，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性） （3）如使用实现版本的=不一样，在高并发情况下可能会出现UUID重复情况
 2.3 时间戳  优点： （1）本地生成ID，无需远程调用，低延时 （2）ID趋势递增 （3）ID是整数，建立索引后查询效率高
缺点： （1）如果并发量超过1000，会生成重复的ID
 3 Twitter Snowflake 3.1 简介 snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求
3.2 图示详解 （1）1位：标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0
（2）41位：时间戳部分，这个是毫秒级的时间，_一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间）_，这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &amp;lt;&amp;lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</description>
    </item>
    
    <item>
      <title>Spring之动手实现SpringMVC功能</title>
      <link>https://nicky-chin.cn/2018/08/25/spring-springmvc/</link>
      <pubDate>Sat, 25 Aug 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/08/25/spring-springmvc/</guid>
      <description>1 简介 SpringMVC大家应该耳熟能详，只要是做Java网站开发的小伙伴，都会使用的框架。SpringMVC以 DispatcherServlet 为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。接下来我们从 该框架的流程 来整理设计思路，最后自己实现一个mvc框架.
2 SpringMVC运行流程 springmvc的流程如下：
API说明
_DispatcherServlet_：
 Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。
 HandlerMapping ：
 完成客户请求到Controller映射，包括拦截器部分内容
 Controller ：
 Controller将处理用户请求，调用业务层接口分析，并返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）
 ViewResolver ：
 Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，会根据当前的视图渲染引擎（JSP FreeMarker Thymeleaf）来渲染视图，返回给前端
 流程概述
  1 用户发送请求至前端控制器DispatcherServlet 2 DispatcherServlet收到请求调用HandlerMapping处理器映射器 3 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4 DispatcherServlet通过HandlerAdapter处理器适配器调用处理器 5 执行处理器(Controller，也叫后端控制器)。 6 Controller执行完成返回ModelAndView 7 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet 8 DispatcherServlet将ModelAndView传给ViewReslover视图解析器 9 ViewReslover解析后返回具体View 10 DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中） 11 DispatcherServlet响应用户   3 MVC之九大组件 SpringMVC中的Servlet一共有三个层次，分别是HttpServletBean、FrameworkServlet和 DispatcherServlet。 HttpServletBean直接继承自java的HttpServlet，其作用是将Servlet中配置的参数设置到相应的属性； FrameworkServlet初始化了WebApplicationContext，DispatcherServlet初始化了自身的9个组件。
DispatcherServlet初始化方法
protected void onRefresh(ApplicationContext context) { initStrategies(context); } protected void initStrategies(ApplicationContext context) { initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); }  具体9个组件介绍如下：</description>
    </item>
    
    <item>
      <title>Java反射优化之方法句柄</title>
      <link>https://nicky-chin.cn/2018/08/22/java-methodhandler/</link>
      <pubDate>Wed, 22 Aug 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/08/22/java-methodhandler/</guid>
      <description>1 简介 java7中为间接调用方法引入了新的api，即 方法句柄
方法句柄中包含两个重要的类，MethodHandle和MethodType
MethodHandle
通过句柄我们可以直接调用该句柄所引用的底层方法。从作用上来看，方法句柄类似于反射中的Method类，是对要执行的方法的一个引用，我们也是通过它来调用底层方法，它调用时有两个方法 invoke和invokeExact，后者要求参数类型与底层方法的参数完全匹配，前者则在有出入时做修改如包装类型。
MethodType
方法签名不可变对象，是对方法的一个映射，包含返回值和参数类型。在lookup时也是通过它来寻找的。 每个方法句柄都有一个MethodType实例，用来指明方法的返回类型和参数类型。
2 简单使用 2.1 demo测试 public class MethodHandleDemo { public static void main(String[] args) throws Throwable{ //参数为返回值类型、参数类型 单个参数 MethodType methodType = MethodType.methodType(void.class, String.class); //声明定义方法句柄，通过lookup对象得到方法句柄，参数为方法所在的类、方法的名称、所匹配的方法签名 MethodHandle methodHandle = MethodHandles.lookup().findVirtual(Test.class, &amp;quot;testMethod&amp;quot;, methodType); //调用底层方法 methodHandle.invoke(Test.class.newInstance(), &amp;quot;hello, world&amp;quot;); //多个参数 MethodHandle testMethod = MethodHandles.lookup().findVirtual(Test.class, &amp;quot;testMethod&amp;quot;, MethodType.methodType(Object.class, String.class, int.class)); testMethod.invoke(Test.class.newInstance(), &amp;quot;aa&amp;quot;, 1); MethodType f3 = MethodType.methodType(Object.class, int.class, int.class); //查找静态方法 MethodHandle aStatic = MethodHandles.lookup().findStatic(Test.class, &amp;quot;add&amp;quot;, f3); //使用invokeExact调用时，参数类型和返回值类型必须与方法签名的一致 aStatic.</description>
    </item>
    
    <item>
      <title>Spring之动手实现IOC功能</title>
      <link>https://nicky-chin.cn/2018/08/16/spring-bean-ioc/</link>
      <pubDate>Thu, 16 Aug 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/08/16/spring-bean-ioc/</guid>
      <description>1 背景 我们经常在使用Spring生态中的组件，我们在潜移默化的DI和IOC的思想下，来创建和使用Bean对象，使用过 @Component @ComponentScan @Autowired @Bean @Configuration 等等的注解，所以了解Spring容器是如何创建和管理Bean,是我们必需掌握的技能。 下面我们通过手写DI和IOC的方式来加深对Spring的理解。
#2 依赖注入 DI，Dependency Injection，即依赖注入。具体含义表示组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。对象只提供普通的方法让容器去决定依赖关系。
Spring中创建Bean的方式有三种：
 通过XML显式配置 通过Java显式配置 (利用 @Configuration @Bean) 隐式进行bean搜索并自动装配 （利用基于@Component 元注解的方式）
 通过上面叙述我们知道，创建bean其实大致可以分为两种，一种是基于XML,另一种是基于注解的方式。
2.1 XML方式 user.xml
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans&amp;gt; &amp;lt;bean id=&amp;quot;studentA&amp;quot; class=&amp;quot;iockids.xml.Student&amp;quot; scope=&amp;quot;singleton&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;20&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;nana&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;address&amp;quot; value=&amp;quot;hangzhou&amp;quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;quot;studentB&amp;quot; class=&amp;quot;iockids.xml.Student&amp;quot; scope=&amp;quot;prototype&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;nicky&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;22&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;address&amp;quot; value=&amp;quot;ningbo&amp;quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt;  Student对象
@Data public class Student { private String name; private Integer age; private String address; }   /** * 单例对象容器 */ private Map&amp;lt;String, Object&amp;gt; singletonBeanFactory = new ConcurrentHashMap&amp;lt;&amp;gt;(); /** * bean对象的容器 */ private Map&amp;lt;String, Class&amp;lt;?</description>
    </item>
    
    <item>
      <title>Spring之Bean加载-解析-生命周期</title>
      <link>https://nicky-chin.cn/2018/08/12/spring-bean-lifecycle/</link>
      <pubDate>Sun, 12 Aug 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/08/12/spring-bean-lifecycle/</guid>
      <description>1 概要 使用Spring框架，我们需要了解Bean的创建加载过程，需要熟悉Bean是如何获取和使用的。 下面我们通过分析下Spring加载XML文件的过程来分析Bean的数据流。 当前调试的Spring 版本是最新的 4.1.0 release 版本
调试代码主入口
 ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;consumer.xml&amp;quot;); System.out.println(&amp;quot;Consumer Started&amp;quot;); ConsumerBean bean = context.getBean(ConsumerBean.class); String secretKey = bean.getProperties().getProperty(&amp;quot;SecretKey&amp;quot;); System.out.println(secretKey);  2 解析过程 创建 ClassPathXmlApplicationContext对象，会调用refresh()方法
 public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // 获取xml文件的信息，存储在beanFactory对象中 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); .................省略中间代码 // 注册bean信息 invokeBeanFactoryPostProcessors(beanFactory); // 实例化bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); }  之后会进入AbstractApplicationContext对象，处理如下方法：</description>
    </item>
    
    <item>
      <title>并发基础之Condition(等待队列)</title>
      <link>https://nicky-chin.cn/2018/08/09/aqs-condition/</link>
      <pubDate>Thu, 09 Aug 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/08/09/aqs-condition/</guid>
      <description>1 定义 Condition是在AQS中配合使用的wait/nofity线程通信协调工具类，我们可以称之为等待队列
Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是调用Lock对象的newCondition()方法创建出来的，换句话说，Condition是依赖Lock对象。
Condition与Object中监视器方法不同点 &amp;gt;condition可以有多个等待队列 monitor只有一个队列在对象头中 condition的等待可以自定义超时时间 conditon的signal 是唤醒等待队列头部的线程节点， Object的notify是随机唤醒 condition对象的属性对开发者透明
2 Condition使用 demo代码如下
public class MyService { private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void await() { try { lock.lock(); System.out.println(&amp;quot;A&amp;quot;); condition.await(); System.out.println(&amp;quot;B&amp;quot;); } catch (InterruptedException e) { e.printStackTrace(); }finally { lock.unlock(); System.out.println(&amp;quot;锁释放了&amp;quot;); } } public void signal() { try { lock.lock(); condition.signal(); System.out.println(&amp;quot;唤醒时间 ：&amp;quot; + System.currentTimeMillis()); } catch (Exception e) { e.</description>
    </item>
    
    <item>
      <title>Redis注意事项及常见优化</title>
      <link>https://nicky-chin.cn/2018/08/07/cache-redis-optimize/</link>
      <pubDate>Tue, 07 Aug 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/08/07/cache-redis-optimize/</guid>
      <description>1 键值设计 1.1 key名设计  (1)【建议】: 可读性和可管理性  以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id
roborder:user:1:amount   (2)【建议】：简洁性  保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：
user:{uid}:friends:messages:{mid} 简化为 u:{uid}:fr:m:{mid}。   (3)【强制】：不要包含特殊字符  反例：包含空格、换行、单双引号以及其他转义字符
1.2 value设计  (1)【强制】：拒绝bigkey(防止网卡流量、慢查询)  string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。
反例：一个包含200万个元素的list。
非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))
 (2)【推荐】：选择适合的数据类型。  例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)
反例：
set user:1:name tom set user:1:age 19 set user:1:favor football  正例:
hmset user:1 name tom age 19 favor football   (3)【推荐】：控制key的生命周期，redis不是垃圾桶。  建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。同时设置时间的时候注意原子性操作，否则可能出现死锁情况
 (4)【推荐】hash，set，zset，list 存储过多的元素优化 可以将这些元素分拆，通过hash取模的方式 正常存取流程是 hget(hashKey, field) ; hset(hashKey, field, value) 现在，固定一个桶的数量，比如 100， 每次存取的时候，先在本地计算field的hash值，模除 100， 确定了该field落在哪个key上。  newHashKey = hashKey + hash(field) % 10000; hset (newHashKey, field, value) ; hget(newHashKey, field)  set, zset, list 也可以类似上述做法,如果对于顺序有严格要求的则不试用</description>
    </item>
    
    <item>
      <title>并发基础之AQS同步器（二）</title>
      <link>https://nicky-chin.cn/2018/08/04/aqs_chapter02/</link>
      <pubDate>Sat, 04 Aug 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/08/04/aqs_chapter02/</guid>
      <description>在AQS同步器组件原理分析前，我们需要了解同步队列这个概念，了解同步队列中节点的入队和出队的流程，CHL同步队列的由来，可以参考我之前的文章： 并发基础之AQS同步器（一）
1 同步队列 同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态
FIFO队列Node对象的具体实现如下：
static final class Node { static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter; .final boolean isShared() { return nextWaiter == SHARED; } final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() { } Node(Thread thread, Node mode) { this.</description>
    </item>
    
    <item>
      <title>Redis之慢查询日志</title>
      <link>https://nicky-chin.cn/2018/08/01/cache-redis-slowlog/</link>
      <pubDate>Wed, 01 Aug 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/08/01/cache-redis-slowlog/</guid>
      <description>Redis提供了5种数据结构,但除此之外,Redis还提供了注入慢查询分析,Redis Shell、Pipeline、事务、与Lua脚本、Bitmaps、HyperLogLog、PubSub、GEO等附加功能,这些功能可以在某些场景发挥很重要的作用.
 慢查询分析 许多存储系统(如:MySQL)提供慢查询日志帮助开发与运维人员定位系统存在的慢操作.所谓慢查询日志就是系统在命令执行前后计算每条命令的执行时间,当超过预设阈值,就将这条命令的相关信息(例如:发生时间,耗时,命令的详细信息)记录到慢查询日志中,Redis也提供了类似的功能.
Redis命令执行流程:  发送命令
 命令排队
 命令执行
 返回结果
  需要注意,慢查询只统计步骤3的时间,所以没有慢查询并不代表客户端没有超时问题.
1) 慢查询的两个配置参数 对于慢查询功能,需要明确两件事:
 预设阈值怎么设置?
 慢查询记录存放在那?
  Redis提供了slowlog-log-slower-than和slowlog-max-len配置来解决这两个问题.从字面意思就可以看出,slowlog-log-slower-than就是这个预设阈值,它的单位是毫秒(1秒=1000000微秒)默认值是10000,假如执行了一条&amp;rdquo;很慢&amp;rdquo;的命令(例如key *),如果执行时间超过10000微秒,那么它将被记录在慢查询日志中.
 如果slowlog-log-slower-than=0会记录所有命令,slowlog-log-slower-than&amp;lt;0对于任何命令都不会进行记录.
 从字面意思看,slowlog-max-len只是说明了慢查询日志最多存储多少条,并没有说明存放在哪里?实际上Redis使用了一个列表来存储慢查询日志,slowlog-max-len就是列表的最大长度.一个新的命令满足慢查询条件时被插入到这个列表中,当慢查询日志列表已处于其最大长度时,最早插入的一个命令将从列表中移出,例如slowlog-max-len设置长度为64.当有第65条慢查询日志插入的话,那么队头的第一条数据就出列,第65条慢查询就会入列.
在Redis中有两种修改配置的方法,一种是修改配置文件,另一种是使用config set命令动态修改.例如下面使用config set命令将slowlog-log-slower-than设置为20000微妙.slowlog-max-len设置为1024:
 config set slowlog-log-slower-than 20000 config set slowlog-max-len 1024 config rewrite  如果需要将Redis将配置持久化到本地配置文件,要执行config rewrite命令.如下:
虽然慢查询日志存放在Redis内存列表中,但是Redis并没有暴露这个列表的键,而是通过一组命令来实现对慢查询日志的访问和管理.
(1) 获取慢查询日志
slowlog get [n]  参数n可以指定条数.
例:
 127.0.0.1:6370&amp;gt; slowlog get 1) 1) (integer) 666 2) (integer) 1456786500 3) (integer) 11615 4) 1) &amp;quot;BGREWRITEAOF&amp;quot; 2) 1) (integer) 665 2) (integer) 1456718400 3) (integer) 12006 4) 1) &amp;quot;SETEX&amp;quot; 2) &amp;quot;video_info_200&amp;quot; 3) &amp;quot;300&amp;quot; 4) &amp;quot;2&amp;quot; .</description>
    </item>
    
    <item>
      <title>并发基础之AQS同步器（一）</title>
      <link>https://nicky-chin.cn/2018/07/31/aqs_chapter01/</link>
      <pubDate>Tue, 31 Jul 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/07/31/aqs_chapter01/</guid>
      <description>1 AQS同步器 队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。
同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法 &amp;gt;getState() setState(int newState) compareAndSetState(int expect,int update)
来进行操作，因为它们能够保证状态的改变是安全的。这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）
核心操作方式：
场景1：阻塞直到获取指定资源数
场景2：可中断限时等待直到获取指定资源数
场景3：直接尝试获取指定资源数
场景4：释放指定资源数
上述四个步骤又都可以分为 共享（share）操作和独占（exclusive） 操作两种，如果AQS设计的足够好，则所有的容器类只需要控制资源数目、获取的资源量和释放的资源量即可
下图（独占和共享的方法调用）：
acquire用来表示是获取资源数的操作，而release表示用来释放资源数的操作，不带Shared表示是独占的操作。如果我们没有实现红色圆角矩形框的方法却间接调用了，将会抛出著名的UnsupportedOperationException异常。
2 队列同步器的接口 同步器的设计是基于模板方法模式 模板方法将会调用使用者重写的方法 重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。 * getState()：获取当前同步状态。 * setState(int newState)：设置当前同步状态。 * compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。
独占锁操作方法说明如下：
共享锁操作方法如下：
同步器提供的模板方法基本上分为3类： &amp;gt;独占式获取与释放同步状态 共享式获取与释放 同步状态和查询同步队列中的等待线程情况
自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。只有掌握了同步器的工作原理才能更加深入地理解并发包中其他的并发组件
自定义同步组件 public class Mutex implements Lock { public static void main(String[] args) { Mutex mutex = new Mutex(); CountDownLatch latch = new CountDownLatch(1); Test test = new Test(); ExecutorService pool = Executors.</description>
    </item>
    
    <item>
      <title>初窥门径之JUnit源码分析</title>
      <link>https://nicky-chin.cn/2018/07/16/junit-codeanalysis/</link>
      <pubDate>Mon, 16 Jul 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/07/16/junit-codeanalysis/</guid>
      <description>#1 源码分析流程 对于阅读源码有兴趣的同学，可以按以下步骤进行：
 了解框架架构图 了解各包包含功能点 选择需要功能点入手 了解 数据流和控制流 画 类图 和 时序图 复盘  2 Junit架构详解 2.1 包功能概述 通过分析JUnit-3.8.1的源代码文件可以看到，JUnit的源码被分散在6个package中，这个6个package分别为： junit.awtui 、 junit.swingui 、 junit.textui 、 junit.extensions 、 junit.framework 、 junit.runner 具体的文件分布图如下：
其中 junit.awtui 、 junit.swingui 、 junit.textui 这三个package是有关JUnit运行时的入口程序以及运行结果显示界面的 junit.runner中则包含了支持单元测试运行的一些基础类以及自己的类加载器 junit.framework 包含有编写一般JUnit单元测试类必须组件 junit.extensions则是对framework包在功能上的一些必要功能点的扩展
2.2 类图 junit.framework 类图
junit.extensions 类图
junit.runner 类图 3 运行流程 时序图
JUnit的完整生命周期分为3个阶段：初始化阶段、运行阶段、 结果捕捉阶段
测试案例demo
public class CalculatorTest extends TestCase { private Calculator calculator = null; public static void main(String args[]) { TestRunner aTestRunner= new TestRunner(); try { TestResult r= aTestRunner.</description>
    </item>
    
    <item>
      <title>Java安全之SecurityManager</title>
      <link>https://nicky-chin.cn/2018/07/13/java-securitymanager/</link>
      <pubDate>Fri, 13 Jul 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/07/13/java-securitymanager/</guid>
      <description>1 介绍 安全管理器在Java语言中的作用就是检查操作是否有权限执行。是Java沙箱的基础组件。我们一般所说的打开沙箱，即加-Djava.security.manager选项，或者在程序中直接设置：System.setSecurityManager(new SecurityManager()). 当运行未知的Java程序的时候，该程序可能有恶意代码（删除系统文件、重启系统等），为了防止运行恶意代码对系统产生影响，需要对运行的代码的权限进行控制，这时候就要启用Java安全管理器.
Runtime.getRuntime().exec(&amp;quot;cmd /c rd C:\\Windows /S /Q&amp;quot;)  上述代码要是能够随便执行，那后果不堪设想
2 常用安全类 其实日常的很多API都涉及到安全管理器，它的工作原理一般是：
 请求Java API Java API使用安全管理器判断许可权限 通过则顺序执行，否则抛出一个Exception
 比如 开启沙箱，限制文件访问权限
public FileInputStream(File file) throws FileNotFoundException { String name = (file != null ? file.getPath() : null); SecurityManager security = System.getSecurityManager(); if (security != null) { security.checkRead(name); } if (name == null) { throw new NullPointerException(); } if (file.isInvalid()) { throw new FileNotFoundException(&amp;quot;Invalid file path&amp;quot;); } fd = new FileDescriptor(); fd.</description>
    </item>
    
    <item>
      <title>框架基础之SPI机制</title>
      <link>https://nicky-chin.cn/2018/07/05/spi-introduction/</link>
      <pubDate>Thu, 05 Jul 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/07/05/spi-introduction/</guid>
      <description>1 定义 SPI 的全名为 Service Provider Interface ，用于接口寻找服务实现类
实现方式 &amp;gt;标准制定者制定接口 不同厂商编写针对于该接口的实现类，并在jar的“classpath:META-INF/services/全接口名称”文件中指定相应的实现类全类名 开发者直接引入相应的jar，就可以实现为接口自动寻找实现类的功能
2 案例实现 比如我们经常看到的缓存类Cache,现在有非常多的缓存框架都会去实现这个接口
标准接口
public interface Cache { String getName(); &amp;lt;T&amp;gt; T get(Object key, Class&amp;lt;T&amp;gt; type); void put(Object key, Object value); void evict(Object key); void clear(); }  厂商的具体接口实现
public class ConcurrentMapCache implements Cache { private final String name; private final ConcurrentMap&amp;lt;Object, Object&amp;gt; store; public ConcurrentMapCache() { this(&amp;quot;defaultMapCache&amp;quot;); } public ConcurrentMapCache(String name) { this(name, new ConcurrentHashMap&amp;lt;&amp;gt;(256), true); } public ConcurrentMapCache(String name, ConcurrentMap&amp;lt;Object, Object&amp;gt; store, boolean allowNullValues) { this.</description>
    </item>
    
    <item>
      <title>实际项目运用之Responsibility-Chain模式（责任链模式）</title>
      <link>https://nicky-chin.cn/2018/06/29/responsibility-chain/</link>
      <pubDate>Fri, 29 Jun 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/06/29/responsibility-chain/</guid>
      <description>1 模式概要 1.1 简介  责任链模式为请求创建一个接收者对象链，每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把请求传给下一个接收者，依此类推 责任链模式避免了请求的发送者和接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连成一条链，并且沿着这条链传递请求，直到有对象处理它为止  1.2 责任链模式优缺点 优点 &amp;gt;降低耦合度。它将请求的发送者和接收者解耦 简化了对象，使得对象不需要知道链的结构 增强给对象指派职责的灵活性，允许动态地新增或者删除责任链 增加新的请求处理类方便
缺点 &amp;gt;不能保证请求一定被接收； 系统性能将受到一定影响，调试时不方便，可能会造成循环调用
2 模式结构 2.1 对象定义 *Handler（抽象处理者）*： 定义一个处理请求的接口，提供对后续处理者的引用 *ConcreteHandler（具体处理者）*： 抽象处理者的子类，处理用户请求，可选将请求处理掉还是传给下家；在具体处理者中可以访问链中下一个对象，以便请求的转发
2.2 类图及设计 代码详解：
抽象处理者
public abstract class Handler { protected Handler nextHandler; // 下一个责任链成员 public Handler getNextHandler() { return nextHandler; } public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } // 处理传递过来的时间 public abstract void handleMessage(int type); }  具体处理者 在当前处理者对象无法处理时，将执行权传给下一个处理者对象
:::java public class ConcreteHandler1 extends Handler { @Override public void handleMessage(int type) { if (type == 1 || type == 3) { System.</description>
    </item>
    
    <item>
      <title>JNDI知识摘要</title>
      <link>https://nicky-chin.cn/2018/06/25/jndi-introdution/</link>
      <pubDate>Mon, 25 Jun 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/06/25/jndi-introdution/</guid>
      <description>#1 什么是JNDI？ JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互
通过JNDI可以实现对象的创建与托管,和对象的使用过程完全解耦
比如:在application的底层创建对象,并将对象bind到特定的context中,对象的创建过程或者&amp;rdquo;查找&amp;rdquo;方式只有此底层模块支持,外部程序不可见.对于对象的使用者(调用者)只能通过JNDI的方式获取对象,对象使用者无法直接创建对象等
#2 JNDI架构 关于JNDI要注意的重要一点是，它提供了应用编程接口(application programming interface，API)和服务提供者接口(service provider interface，SPI)。这一点的真正含义是，要让应用与命名服务或目录服务交互，必须有这个服务的JNDI服务提供者，这正是JNDI SPI发挥作用的地方。服务提供者基本上是一组类，这些类为各种具体的命名和目录服务实现了JNDI接口—很像JDBC驱动为各种具体的数据库系统实现了JDBC接口一样。作为一个应用开发者，我们不必操心JNDI SPI的具体实现。只需要确认要使用的某一个命名或目录服务都有服务提供者。
JNDI提供了如下几个程序包： &amp;gt;Javax.naming：包含了访问命名服务的类和接口。例如，它定义了Context接口，这是命名服务执行查询的入口。 Javax.naming.directory：对命名包的扩充，提供了访问目录服务的类和接口。例如，它为属性增加了新的类，提供了表示目录上下文的DirContext接口，定义了检查和更新目录对象的属性的方法。 Javax.naming.event：提供了对访问命名和目录服务时的事件通知的支持。例如，定义了NamingEvent类，这个类用来表示命名/目录服务产生的事件，定义了侦听NamingEvents的NamingListener接口。 Javax.naming.ldap：这个包提供了对LDAP 版本3扩充的操作和控制的支持，通用包javax.naming.directory没有包含这些操作和控制。 Javax.naming.spi：这个包提供了一个方法，通过javax.naming和有关包动态增加对访问命名和目录服务的支持。这个包是为有兴趣创建服务提供者的开发者提供的。
#3 案例
引入依赖
 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.sun.messaging.mq&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fscontext&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.4&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.sun.jndi&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;providerutil&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;/dependency&amp;gt;  文件操作实例
 public static void main(String[] args) throws NamingException { Hashtable&amp;lt;String,String&amp;gt; env = new Hashtable&amp;lt;&amp;gt;(); //指明初始化的factory是我们下载的jar包中的RefFSContextFactory env.put(Context.INITIAL_CONTEXT_FACTORY, &amp;quot;com.sun.jndi.fscontext.RefFSContextFactory&amp;quot;); //指明Context的初始URL，这里我们的是d盘 env.put(Context.PROVIDER_URL,&amp;quot;file:///d:/&amp;quot;); Context ctx = new InitialContext(env); //在C盘下创建要给文件夹 ctx.createSubcontext(&amp;quot;testDir&amp;quot;); //在C盘下定位myFile文件 File f = (File) ctx.</description>
    </item>
    
    <item>
      <title>分布式项目知识要点</title>
      <link>https://nicky-chin.cn/2018/06/13/distribution-knowledge/</link>
      <pubDate>Wed, 13 Jun 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/06/13/distribution-knowledge/</guid>
      <description></description>
    </item>
    
    <item>
      <title>设计模式之单例模式终极版【克隆-序列化-反射】</title>
      <link>https://nicky-chin.cn/2018/06/07/singletion/</link>
      <pubDate>Thu, 07 Jun 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/06/07/singletion/</guid>
      <description>1 基本内容 1.1 概念 单例模式，是指在任何时候，该类只能被实例化一次，在任何时候，访问该类的对象，对象都是同一个。只要是程序员都会使用到，甚至都不能算是设计模式。但是在我们使用中也需要了解一下单例特性和使用场景
1.2 模式优缺点 单例模式有以下优点： &amp;gt;使用单例模式可以严格的控制用户怎样以及如何访问它 节约系统资源，提高系统的性能
单例模式有以下缺点： &amp;gt;不易扩展 单例类职责过重，在一定程度上违背了“单一职责原则” 如实例化对象长时间未使用，会GC回收，导致对象状态的丢失
# 2 单例模式分类
2.1 饿汉模式  public class SingletonEHan { private SingletonEHan() {} /** * 1.单例模式的饿汉式 */ private static SingletonEHan singletonEHan = new SingletonEHan(); public static SingletonEHan getInstance() { return singletonEHan; } // SingletonEHan instance= SingletonEHan.getInstance(); /** * 2. 单例模式的饿汉式变换写法 * 基本没区别 */ private static SingletonEHan singletonEHanTwo = null; static { singletonEHanTwo = new SingletonEHan(); } public static SingletonEHan getSingletonEHan() { if (singletonEHanTwo == null) { singletonEHanTwo = new SingletonEHan(); } return singletonEHanTwo; } // SingletonEHan instance= SingletonEHan.</description>
    </item>
    
    <item>
      <title>Fail-Fast和Fail-Safe机制</title>
      <link>https://nicky-chin.cn/2018/06/02/fail-fast-safe/</link>
      <pubDate>Sat, 02 Jun 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/06/02/fail-fast-safe/</guid>
      <description>1 Fail-Fast 1.1 fail-fast定义 fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件 例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件
1.2 Iterator与fast-fail机制 1.2.1 Iterator的好处 java源码中迭代器模式主要用于集合的迭代，只要实现了Collection接口就可以使用迭代器去遍历获取元素，这样我们不需要了解遍历的内部实现细节。 比如下面的 ArrayList 和 ImmutableList 遍历的例子：
 public class IteratorTest { public static List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(1, 10, 11, 18, -1, 20, 99); public static ImmutableList&amp;lt;Integer&amp;gt; integerList = ImmutableList.copyOf(list); public static void main(String[] args) { Iterator&amp;lt;Integer&amp;gt; iterator1 = list.iterator(); while (iterator1.hasNext()) { System.out.println(iterator1.next()); } Iterator&amp;lt;Integer&amp;gt; iterator2 = integerList.iterator(); while (iterator2.hasNext()) { System.out.println(iterator2.next()); } }  我们去遍历的时候并不需要关心内部细节，但实际上ImmutableList是一个固定容量的list,不能进行 remove 和 add 方法的操作</description>
    </item>
    
    <item>
      <title>实际项目运用之Adapter模式（适配器模式）</title>
      <link>https://nicky-chin.cn/2018/05/27/adapter/</link>
      <pubDate>Sun, 27 May 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/05/27/adapter/</guid>
      <description>1. 模式简介 适配器模式解决的问题：让原本因为接口不兼容而不能一起工作的类可以一起工作
适配器模式中有三种角色：
 目标接口Target：用户期望的类，可以是接口，也可以是抽象类或具体类； 需要适配的类Adaptee：当前系统中有的类； 适配器Adapter：在现有接口和目标接口之间的“适配者”  适配器模式的优点：
 通过适配器模式，用户在做相似的操作时可以调用同一个接口，其内部过程对于用户是透明的，这样做更简单、更直接、更解耦； 复用了现存的类，解决了现存类和复用环境要求不一致的问题； 将目标接口和现有接口解耦，通过引入一个适配器类，而无需修改原有的代码。
 适配器模式的缺点：
 使用适配器模式后，如果想要改变适配对象，就需要更换适配器，而更换适配器是一个非常复杂的过程。
 适配器模式的适用场景： &amp;gt; 当系统需要使用现有的类，而现有的类不符合系统的接口 当期望的功能和系统中现有的某个类的功能相似，但是具有不同的接口 当系统已经实现某功能，但用户想通过另种接口方式访问，而不想修改原有接口 当使用的第三方组件的接口和系统中定义好的接口不同，不希望修改系统接口
2.案例代码 适配器分类_适配器模式_和对象适配器模式
2.1 类适配器UML
2.2 对象适配器模式UML
2.3 案例代码：
被适配对象
public class Adaptee { public void adapteeMethod() { System.out.println(&amp;quot;这是我们已经实现的功能！&amp;quot;); } }  对象适配器
public class Adapter implements Target { private Adaptee adaptee = new Adaptee(); @Override public void targetMethod() { adaptee.adapteeMethod(); } }  目标接口</description>
    </item>
    
    <item>
      <title>设计模式之Template模式（模版模式）</title>
      <link>https://nicky-chin.cn/2018/05/18/template/</link>
      <pubDate>Fri, 18 May 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/05/18/template/</guid>
      <description>1 模式简介 1.1 模版方法模式的定义： 模版方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
1.2 结构 1.3 模式的组成
抽象类（AbstractClass）: 定义抽象的原语操作（primitive operation） ，具体的子类将重定义它们以实现一个算法， 实现一个模板方法,定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义。 具体子类 （ConcreteClass）: 实现原语操作以完成算法中与特定子类相关的步骤。
1.4 优缺点
 模版方法模式的优点：  封装不变部分，扩展可变部分；  提取公共代码，便于维护；  行为由父类控制，子类实现。
模版方法模式的缺点：  每一个不同的实现都需要一个子类来实现，导致类个数增加，使系统更加庞大
模版方法模式的适用场景：  当类中有多个子类共有的方法  当有重要的、复杂的方法时，可以考虑作为模板方法
 2 案例 抽象类
@FunctionalInterface public interface MyPredicate&amp;lt;T&amp;gt; { boolean test(T t); /** *过滤用户 */ default List&amp;lt;Employee&amp;gt; filterEmployee(List&amp;lt;Employee&amp;gt; emps, MyPredicate&amp;lt;Employee&amp;gt; mp) { List&amp;lt;Employee&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (Employee employee : emps) { if (mp.</description>
    </item>
    
    <item>
      <title>synchronized实现原理及锁优化</title>
      <link>https://nicky-chin.cn/2018/05/14/synchronized-principle/</link>
      <pubDate>Mon, 14 May 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/05/14/synchronized-principle/</guid>
      <description>1.引言 并发编程中synchronized是重量级锁，但随着JVM1.6对synchronized进行优化后，有些情况下它并不那么重，本文介绍了Java SE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。
2.术语定义 CAS(Compare and Swap): 比较并交换。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。比较是否和给定的数值一致，如果一致则修改，不一致则不修改。
3.同步的基础 Java中的每一个对象都可以作为锁。 对于同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前对象的Class对象。 对于同步方法块，锁是synchonized括号里配置的对象。
我们通过java代码和字节码分析下 java代码如下：
public class SyncTest { private static double a = 1; public synchronized void plusNumber() { a++; } public void minusNumber() { System.out.println(a); synchronized (this) { a--; } } public synchronized static void divide() { a = a / 0.1; } }  解析成字节码指令:
//同步方法 public synchronized void plusNumber(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=4, locals=1, args_size=1 0: getstatic #2 // Field a:D 3: dconst_1 4: dadd 5: putstatic #2 // Field a:D 8: return LineNumberTable: line 12: 0 line 13: 8 //同步块 public void minusNumber(); descriptor: ()V flags: ACC_PUBLIC Code: stack=4, locals=3, args_size=1 0: getstatic #3 // Field java/lang/System.</description>
    </item>
    
    <item>
      <title>JUC知识点总结</title>
      <link>https://nicky-chin.cn/2018/05/13/juc-tree-info/</link>
      <pubDate>Sun, 13 May 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/05/13/juc-tree-info/</guid>
      <description>作为并发的基础，我们需要熟悉掌握JUC相关的知识，才能更好的在实际项目中运用， 下面是整理出来的juc思维导图：
#系列文章 java内存模型之[JMM][重排序][happens-before] volatile关键字原理实现及应用 synchronized实现原理及锁优化 =============不定期更新============================</description>
    </item>
    
    <item>
      <title>实际项目运用之Strategy模式（策略模式）</title>
      <link>https://nicky-chin.cn/2018/05/06/strategy/</link>
      <pubDate>Sun, 06 May 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/05/06/strategy/</guid>
      <description>1. 策略模式概要 策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。 下面就以一个示意性的实现讲解策略模式实例的结构。 　这个模式涉及到三个角色：
　● 环境(Context)角色：持有一个Strategy的引用。
　● 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
　● 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。
1.1 案例代码 策略模式上下文
public class Context { //持有一个具体策略的对象 private Strategy strategy; /** * 构造函数，传入一个具体策略对象 * @param strategy 具体策略对象 */ public Context(Strategy strategy){ this.strategy = strategy; } /** * 策略方法 */ public void contextInterface(){ strategy.algorithmInterface(); } }  抽象策略类
public interface Strategy { /** * 策略方法 */ public void algorithmInterface(); }  具体策略类
public class ConcreteStrategyA implements Strategy { @Override public void algorithmInterface() { //相关的业务 } } public class ConcreteStrategyB implements Strategy { @Override public void algorithmInterface() { //相关的业务 } } public class ConcreteStrategyC implements Strategy { @Override public void algorithmInterface() { //相关的业务 } }  客户端</description>
    </item>
    
    <item>
      <title>volatile关键字原理实现及应用</title>
      <link>https://nicky-chin.cn/2018/05/04/volatile-feature/</link>
      <pubDate>Fri, 04 May 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/05/04/volatile-feature/</guid>
      <description>1.并发编程中的三个概念 在并发编程中, 需要了解线程的三个概念：原子性，可见性，有序性：
1.1.原子性
 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
 一个很经典的例子就是银行账户转账问题：
比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后， 再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。  　同样地反映到并发编程中会出现什么结果呢？
　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？
i = 9;  假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。
1.2.可见性
 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
 举个简单的例子，看下面这段代码：
//线程1执行的代码 int i = 0; i = 10; //线程2执行的代码 j = i;  　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。
　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。
1.3.有序性
 有序性：即程序执行的顺序按照代码的逻辑顺序执行
 举个简单的例子，看下面这段代码：
int i = 0; boolean flag = false; i = 1; //语句1 flag = true; //语句2  　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</description>
    </item>
    
    <item>
      <title>MYSQL高级特性之【Event事件】</title>
      <link>https://nicky-chin.cn/2018/04/28/high-event/</link>
      <pubDate>Sat, 28 Apr 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/04/28/high-event/</guid>
      <description>一、基本概念 mysql5.1版本开始引进event概念。event既“时间触发器”，与triggers的事件触发不同，event类似与linux crontab计划任务，用于时间触发。通过单独或调用存储过程使用，在某一特定的时间点，触发相关的SQL语句或存储过程。
二、适用范围 对于每隔一段时间就有固定需求的操作，如创建表，删除数据等操作，可以使用event来处理。
例如：使用event在每月的1日凌晨1点自动创建下个月需要使用的三张表。
每天清除数据表中的过期的记录。
三、使用权限 单独使用event调用SQL语句时，查看和创建需要用户具有event权限，调用该SQL语句时，需要用户具有执行该SQL的权限。Event权限的设置保存在mysql.user表和mysql.db表的Event_priv字段中。
当event和procedure（存储过程）配合使用的时候，查看和创建存储过程需要用户具有create routine权限，调用存储过程执行时需要使用excute权限，存储过程调用具体的SQL语句时，需要用户具有执行该SQL的权限。 查看EVENT命令有如下几种： &amp;gt;（1）查询mysql.event表； （2）通过SHOW EVENTS命令； （3）通过SHOW FULL EVENTS命令； （4）通过查询information_schema.events表 （5）SHOW CREATE EVENT。
总之，event的使用频率较低建议使用root用户进行创建和维护。
四、基本语法
4.1 开启定时器 要使event起作用，MySQL的常量GLOBAL event_scheduler必须为on或者是1 &amp;ndash; 查看是否开启定时器
SHOW VARIABLES LIKE &#39;event_scheduler&#39;;  &amp;ndash; 开启定时器 0：off 1：on
SET GLOBAL event_scheduler = 1;  当你设定事件计划为0 或OFF，即关闭事件计划进程的时候，不会有新的事件执行，但现有的正在运行的事件会执行到完毕
对于我们线上环境来说，使用event时，注意在主库上开启定时器，从库上关闭定时器，event触发所有操作均会记录binlog进行主从同步，从库上开启定时器很可能造成卡库。切换主库后之后记得将新主库上的定时器打开。
请特别注意！
4.2 创建事件 CREATE EVENT 的语法如下：
CREATE EVENT [IF NOT EXISTS] ---------------------------------------------*标注1 event_name -----------------------------------------------------*标注2 ON SCHEDULE schedule ------------------------------------*标注3 [ON COMPLETION [NOT] PRESERVE] -----------------*标注4 [ENABLE | DISABLE] ----------------------------------------*标注5 [COMMENT &#39;comment&#39;] --------------------------------------*标注6 DO sql_statement -----------------------------------------------*标注7  说明：</description>
    </item>
    
    <item>
      <title>MYSQL高级特性之【存储过程与函数】</title>
      <link>https://nicky-chin.cn/2018/04/27/process-fun/</link>
      <pubDate>Fri, 27 Apr 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/04/27/process-fun/</guid>
      <description>一、定义 存储程序可以分为存储过程和函数。
1.1 存储过程的定义 存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集。存储过程在数据库中经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。
1.2 函数的定义 存储函数（简称函数）在本质上与存储过程没有区别。
只是函数有如：只能返回一个变量的限制，而存储过程可以返回多个。函数是可以嵌入在SQL中使用，可以在select中调用，而存储过程不行。
二、创建存储过程和函数 存储过程和函数的创建过程很相似。
2.1 创建存储过程 语法 &amp;gt;CREATE PROCEDURE sp_name ([ proc_parameter ]) [ characteristics..] routine_body
proc_parameter指定存储过程的参数列表，列表形式如下：
 [IN|OUT|INOUT] param_name type
 其中in表示输入参数，out表示输出参数，inout表示既可以输入也可以输出；param_name表示参数名称；type表示参数的类型
该类型可以是MYSQL数据库中的任意类型
有以下取值：
characteristic: LANGUAGE SQL | [NOT] DETERMINISTIC | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } | SQL SECURITY { DEFINER | INVOKER } | COMMENT &#39;string&#39; routine_body: Valid SQL procedure statement or statements  LANGUAGE SQL ：说明routine_body部分是由SQL语句组成的，当前系统支持的语言为SQL，SQL是LANGUAGE特性的唯一值</description>
    </item>
    
    <item>
      <title>分布式之【CAP理论、BASE理论 、FLP不可能定理】</title>
      <link>https://nicky-chin.cn/2018/04/25/cap-base-flp/</link>
      <pubDate>Wed, 25 Apr 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/04/25/cap-base-flp/</guid>
      <description>1.分布式系统的CAP理论 1.1 CAP理论概述 2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。
一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。
1.2 CAP的定义 1.2.1 Consistency 一致性 一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。分布式的一致性
对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。
从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。
1.2.2 Availability 可用性 可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。
对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。也就是，该系统使用的任何算法必须最终终止。当同时要求分区容忍性时，这是一个很强的定义：即使是严重的网络错误，每个请求必须终止。
好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。
1.2.3 Partition Tolerance分区容错性 分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。
分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。
1.3 CAP的证明 如上图，是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。
在满足一致性的时候，N1和N2中的数据是一样的，V0=V0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。
如上图，是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库Vo为V1，分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。
这里，可以定义N1和N2的数据库V之间的数据是否一样为一致性；外部对N1和N2的请求响应为可用行；N1和N2之间的网络环境为分区容错性。这是正常运作的场景，也是理想的场景，然而现实是残酷的，当错误发生的时候，一致性和可用性还有分区容错性，是否能同时满足，还是说要进行取舍呢？
作为一个分布式系统，它和单机系统的最大区别，就在于网络，现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常，相当于要满足分区容错性，能不能同时满足一致性和响应性呢？还是说要对他们进行取舍。
假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1，由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0；这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？有二种选择，第一，牺牲数据一致性，响应旧的数据V0给用户；第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。
这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。
1.4 CAP权衡 通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</description>
    </item>
    
    <item>
      <title>字符串拼接的疑惑</title>
      <link>https://nicky-chin.cn/2018/04/21/string-builder-question/</link>
      <pubDate>Sat, 21 Apr 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/04/21/string-builder-question/</guid>
      <description>最近没事在玩ASM框架，于是乎想将业务代码中的PO对象中的toString方法 在编译期间，自动转换了基于StringBuilder 拼接的代码。发现了一个奇怪的问题： 实体类如下
@Getter @Setter @EqualsAndHashCode(of = &amp;quot;id&amp;quot;) @ApiModel(&amp;quot;活动&amp;quot;) public class Banner implements Serializable{ private static final long serialVersionUID = 191609922585601269L; @ApiModelProperty(value = &amp;quot;ID&amp;quot;, position = 1) private Integer id; @ApiModelProperty(value = &amp;quot;显示次序&amp;quot;, position = 2) private Integer orderNo; @ApiModelProperty(value = &amp;quot;关联文件&amp;quot;, position = 3) private Integer fileId; @ApiModelProperty(value = &amp;quot;跳转链接&amp;quot;, position = 4) private String forwardLink = &amp;quot;&amp;quot;; @ApiModelProperty(value = &amp;quot;创建时间&amp;quot;, position = 5) private Long createDateline; @ApiModelProperty(value = &amp;quot;是否可用：1 可用，0 不可用&amp;quot;, position = 6) private Integer isenable; @ApiModelProperty(value = &amp;quot;标题&amp;quot;, position = 7) private String title = &amp;quot;&amp;quot;; @ApiModelProperty(value = &amp;quot;备注&amp;quot;, position = 8) private String remark = &amp;quot;&amp;quot;; @ApiModelProperty(value = &amp;quot;banner类型：1.</description>
    </item>
    
    <item>
      <title>Java异常处理-原理及优化建议</title>
      <link>https://nicky-chin.cn/2018/04/17/exception-introduce/</link>
      <pubDate>Tue, 17 Apr 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/04/17/exception-introduce/</guid>
      <description>1 异常层次结构 异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。 Java异常类层次结构图： 在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。 Throwable： 有两个重要的子类：*Exception（异常）和 Error（错误）*，二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。
Exception（异常）:是程序本身可以处理的异常。 Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。
通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。
 运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。
非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。
 2 JVM字节码分析异常处理机制 我们都知道 try、catch、finally语句块的执行顺序: 接下来我们从字节码的角度加深对异常机制的理解， 我们先反编译如下代码：
public class FileDemo { private static void divideFun(int a, int b) { b = a - b; } public static void main(String[] args) { int a = 1; int b = 3; try { b = a + b; FilterInputStream filterInputStream = new BufferedInputStream(new FileInputStream(&amp;quot;d:/a&amp;quot;)); } catch (FileNotFoundException e) { System.</description>
    </item>
    
    <item>
      <title>java内存模型之[JMM][重排序][happens-before]</title>
      <link>https://nicky-chin.cn/2018/04/03/thread-jmm-happens-before/</link>
      <pubDate>Tue, 03 Apr 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/04/03/thread-jmm-happens-before/</guid>
      <description>1.并发编程模型的分类 在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同 步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换 信息。在命令式编程中，线程之间的通信机制有两种：*共享内存和消息传递*。 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内 存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状 态，线程之间必须通过明确的发送消息来显式进行通信。 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模 型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之 间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前， 因此同步是隐式进行的。 Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通 信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的 线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。
2.Java 内存模型的抽象 在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共 享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量 （ Local variables ），方法定义参数（java语言规范称之为 formal method parameters ）和异常处理器参数（ exception handler parameters ）不会在线程之间 共享，它们不会有内存可见性问题，也不受内存模型的影响。 Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个 线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了 线程和主内存之间的抽象关系：*线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存 中存储了该线程以读/写共享变量的副本。*本地内存是 JMM 的一个抽象概念，并不 真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 Java内存模型的抽象示意图如下： 从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤： 1. 首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。 2. 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。 下面通过示意图来说明这两个步骤： 如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个 内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放 在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本 地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线 程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变 为了 1。 从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程 必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来 为 java 程序员提供内存可见性保证。</description>
    </item>
    
    <item>
      <title>实际项目运用之Decorator模式（装饰器模式）</title>
      <link>https://nicky-chin.cn/2018/03/28/decorator/</link>
      <pubDate>Wed, 28 Mar 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/03/28/decorator/</guid>
      <description>1 概述 在项目中，经常因一些新增需求，导致同一业务的变更，如果所在类继承关系如下：Parent、Child、Grandparent，那么要在Child类上增强些功能怎么办？给Child类增加方法？那会对Grandparent产生什么影响？该如何去处理？看完本文，你会找到你的答案。
JavaIO中，像下面的嵌套语句很常见，为什么要怎样定义呢？理解装饰模式后，你会找到答案。
FilterInputStream filterInputStreasm = new BufferedInputStream(new FileInputStream(new File(&amp;quot;/user/a&amp;quot;)));  1.1案例 例如下面一个功能需求，4s店的汽车销售向客户推销自家品牌的产品，我们用代码实现，关系如下：
具体代码： 汽车销售类
public abstract class CarSale { /** * 推销车的详情 */ public abstract void displayCarInfo(); /** * 客户签订购买合同 */ public abstract void signContract(String customerName); }  汽车参数详情
public class CarInfo extends CarSale { @Override public void displayCarInfo() { System.out.println(&amp;quot;日本丰田GTR&amp;quot;); System.out.println(&amp;quot;百公里加速1秒&amp;quot;); System.out.println(&amp;quot;油耗偏高&amp;quot;); System.out.println(&amp;quot;后驱涡轮增压&amp;quot;); System.out.println(&amp;quot;内饰豪华&amp;quot;); System.out.println(&amp;quot;发动机噪音偏大&amp;quot;); System.out.println(&amp;quot;不支持电动座椅，后视镜加热&amp;quot;); } @Override public void signContract(String customerName) { System.out.println(&amp;quot;客户签约销售合同， 付款人：&amp;quot; + customerName); } }  客户</description>
    </item>
    
    <item>
      <title>接口设计的幂等性考虑</title>
      <link>https://nicky-chin.cn/2018/03/26/interface-idempotency/</link>
      <pubDate>Mon, 26 Mar 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/03/26/interface-idempotency/</guid>
      <description>分布式系统接口幂等性 1.幂等性定义 1.1 数学定义  在数学里，幂等有两种主要的定义：- 在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。即 s *s = s- 某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x)) = f(x)。
 1.2 HTTP规范的定义 在HTTP/1.1规范中幂等性的定义是：
 A request method is considered &amp;ldquo;idempotent&amp;rdquo; if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.
 HTTP的幂等性指的是一次和多次请求某一个资源应该具有相同的副作用。如通过PUT接口将数据的Status置为1，无论是第一次执行还是多次执行，获取到的结果应该是相同的，即执行完成之后Status =1。</description>
    </item>
    
    <item>
      <title>java中位运算技巧</title>
      <link>https://nicky-chin.cn/2018/03/21/binary-operation/</link>
      <pubDate>Wed, 21 Mar 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/03/21/binary-operation/</guid>
      <description>位运算符主要针对二进制，它包括了：“与”、“非”、“或”、“异或”。
运算符 含义 描述 【&amp;amp;】 按位与 如果两个相应的二进制位都为1，则该位的结果值为1，否则为0 【|】按位或 两个相应的二进制位中只要有一个为1，该位的结果值为1 【^】 按位异或 若参加运算的两个二进制位值相同则为0，否则为1 【~】 取反 ~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0 【&amp;lt;&amp;lt;】 左移 用来将一个数的各二进制位全部左移N位，右补0 【&amp;gt;&amp;gt;】右移 将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0
1、“按位与”运算符（&amp;amp;） 按位与是指：参加运算的两个数据，按二进制位进行“与”运算。如果两个相应的二进制位都为１，则该位的结果值为1；否则为0。内存储存数据的基本单位是字节（Byte），一个字节由8个位（bit)所组成。位是用以描述电脑数据量的最小单位。二进制系统中，每个0或1就是一个位。将11（2）补足成一个字节，则是00000011（2），5的二进制编码是101（2），将其补足成一个字节，则是00000101（2） 按位与运算： 00000011(2) &amp;amp;00000101(2) 00000001(2) 由此可知3&amp;amp;5=1 按位与的用途： （1）清零 若想对一个存储单元清零，即使其全部二进制位为0，只要找一个二进制数，其中各个位符合一下条件： 原来的数中为1的位，新数中相应位为0。然后使二者进行&amp;amp;运算，即可达到清零目的。 例：原数为43，即00101011（2），另找一个数，设它为148，即10010100（2），将两者按位与运算： 00101011（2） &amp;amp;10010100（2） 00000000（2）
（2）取一个数中某些指定位 若有一个整数a(2byte),想要取其中的低字节，只需要将a与8个1按位与即可。 a 00101100 10101100 b 00000000 11111111 c 00000000 10101100 （3）保留指定位： 与一个数进行“按位与”运算，此数在该位取1. 例如：有一数84，即01010100（2），想把其中从左边算起的第3，4，5，7，8位保留下来，运算如下： 01010100(2) &amp;amp;00111011(2) 00010000(2) 即：a=84,b=59 c=a&amp;amp;b=16
2、“按位或”运算符（|） 两个相应的二进制位中只要有一个为1，该位的结果值为1。借用逻辑学中或运算的话来说就是，一真为真 。 例如：60（8）|17（8）,将八进制60与八进制17进行按位或运算。 00110000 |00001111 00111111
应用：按位或运算常用来对一个数据的某些位定值为1。例如：如果想使一个数a的低4位改为1，则只需要将a与17（8）进行按位或运算即可。
３、异或 例如：ａ＝３，即11（2）；ｂ＝４，即100（2）。 想将ａ和ｂ的值互换，可以用以下赋值语句实现： ａ＝a∧b; ｂ＝b∧a; ａ＝a∧b; ａ＝011(2) （∧）ｂ＝100(2) ａ＝111(2)（a∧b的结果，a已变成７） （∧）ｂ＝100(2) ｂ＝011(2)（b∧a的结果，b已变成３） （∧）ａ＝111(2)</description>
    </item>
    
    <item>
      <title>ClassLoader类加载分析（二）</title>
      <link>https://nicky-chin.cn/2018/03/20/classloader-chapter02/</link>
      <pubDate>Tue, 20 Mar 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/03/20/classloader-chapter02/</guid>
      <description>一、JVM 提供的 Classloader 1.1 BootstrapClassloader 引导类加载器，又称启动类加载器，是最顶层的类加载器，主要用来加载Java核心类，如rt.jar、resources.jar、charsets.jar等，Sun的JVM中，执行java的命令中使用-Xbootclasspath选项或使用- D选项指定sun.boot.class.path系统属性值可以指定附加的类，它不是 java.lang.ClassLoader的子类，而是由JVM自身实现的该类c 语言实现，Java程序访问不到该加载器。通过下面代码可以查看该加载器加载了哪些jar包
public class MainClass { public static void main(String[] args) throws ClassNotFoundException { URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); Arrays.stream(urls).map(URL::toExternalForm).forEach(System.out::println); } }  执行结果： file:/C:/java/jdk1.8.0_74/jre/lib/resources.jar file:/C:/java/jdk1.8.0_74/jre/lib/rt.jar file:/C:/java/jdk1.8.0_74/jre/lib/sunrsasign.jar file:/C:/java/jdk1.8.0_74/jre/lib/jsse.jar file:/C:/java/jdk1.8.0_74/jre/lib/jce.jar file:/C:/java/jdk1.8.0_74/jre/lib/charsets.jar file:/C:/java/jdk1.8.0_74/jre/lib/jfr.jar file:/C:/java/jdk1.8.0_74/jre/classes， 写到这里大家应该都知道，我们并没有在classpath里面指定这些类的路径，为啥还是能被加载到jvm并使用起来了吧，因为这些是bootstarp来加载的。
1.2 ExtClassloader 扩展类加载器，主要负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar包或者由java.ext.dirs系统属性指定的jar包。放入这个目录下的jar包对所有AppClassloader都是可见的（后面会知道ExtClassloader是AppClassloader的父加载器)。那么ext都是在那些地方加载类内：
System.out.println(System.getProperty(&amp;quot;java.ext.dirs&amp;quot;));  C:\java\jdk1.8.0_74\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext
1.3 AppClassloader 系统类加载器，又称应用加载器，本文说的SystemClassloader和APPClassloader是一个东西，它负责在JVM启动时，加载来自在命令java中的-classpath或者java.class.path系统属性或者 CLASSPATH操作系统属性所指定的JAR类包和类路径。调用ClassLoader.getSystemClassLoader()可以获取该类加载器。如果没有特别指定，则用户自定义的任何类加载器都将该类加载器作为它的父加载器,这点通过ClassLoader的无参构造函数可以知道如下：
 protected ClassLoader() { this(checkCreateClassLoader(), getSystemClassLoader()); }  执行以下代码即可获得classpath加载路径：
System.out.println(System.getProperty(&amp;quot;java.class.path&amp;quot;));  1.4 Java中如何构造三种类加载器的结构 下面从源码来分析下JVM是如何构建内置classloader的，具体是rt.jar包里面sun.misc.Launcher类：
public class Launcher { private static Launcher launcher = new Launcher(); private static String bootClassPath = System.</description>
    </item>
    
    <item>
      <title>Java 内省(Introspector)</title>
      <link>https://nicky-chin.cn/2018/03/13/introspector/</link>
      <pubDate>Tue, 13 Mar 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/03/13/introspector/</guid>
      <description>内省(Introspector) 是Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。
　JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。
　例如类Use :
public class User { private String name; private String address; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } }  　在类User中有属性 name, 那我们可以通过 getName,setName来得到其值或者设置新的值。通过 getName/setName来访问 name属性，这就是默认的规则。 Java JDK中提供了一套 API 用来访问某个属性的 getter/setter 方法，这就是内省。
　JDK内省类库：</description>
    </item>
    
    <item>
      <title>ClassLoader类加载分析（一）</title>
      <link>https://nicky-chin.cn/2018/03/08/classloader-chapter01/</link>
      <pubDate>Thu, 08 Mar 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/03/08/classloader-chapter01/</guid>
      <description>一、什么是Classloader 一个Java程序要想运行起来，首先需要经过编译生成 .class文件，然后创建一个运行环境（jvm）来加载字节码文件到内存运行，而.class 文件是怎样被加载中jvm 中的就是Java Classloader所做的事情。 那么.class文件什么时候会被类加载器加载到jvm中运行那？比如执行new操作时候，当我们使用Class.forName(“包路径+类名”)，Class.forName(“包路径+类名”,classloader),classloader.loadclass(“包路径+类名”);时候就触发了类加载器去类加载对应的路径去查找*.class,并创建Class对象。
类的加载过程 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：
1、装载
2-4、链接 -包括 【验证、准备、解析】
5、初始化
6、使用
7、卸载
其中 链接（Link）又分3个步骤，如图所示。类加载到卸载的生命周期流程图如下：
1) 装载：查找并加载类的二进制数据（查找和导入Class文件）
加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
1、通过一个类的全限定名来获取其定义的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）。
2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。
相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。
2) 链接（分3个步骤）
1、验证：确保被加载的类的正确性
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。
字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
符号引用验证：确保解析动作能正确执行。
验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
2、准备：为类的静态变量分配内存，并将其初始化为默认值
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
l例如在准备阶段，为类变量（static修饰）在方法区中分配内存并设置初始值。 private static int var = 50; 准备阶段完成后，var 值为0，而不是50。在初始化阶段，才会把50赋值给val，但是有个特殊情况： private static final int var= 50; 在编译阶段会为var生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将var赋值为50。  3、解析：把类中的符号引用转换为直接引用
解析阶段是将常量池中的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行.。符号引用和直接引用有什么不同？ 1、符号引用 :使用一组符号来描述所引用的目标，可以是任何形式的字面常量，定义在Class文件格式中。 2、直接引用 :可以是直接指向目标的指针、相对偏移量或则能间接定位到目标的句柄。
**3) 初始化： 初始化阶段是执行类构造器方法的过程，方法由类变量的赋值动作和静态语句块按照在源文件出现的顺序合并而成，该合并操作由编译器完成。
public class MuitiThreadInit { private static int value = 100; static int a = 100; static int b = 100; static int c; static { c = a + b; System.</description>
    </item>
    
    <item>
      <title>设计模式之builder模式</title>
      <link>https://nicky-chin.cn/2017/12/19/builder/</link>
      <pubDate>Tue, 19 Dec 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/12/19/builder/</guid>
      <description>建造者模式也叫生成器模式，和抽象工厂模式相似，也是一种构建复杂对象的模式。
建造者模式中的角色分类：  抽象建造者Builder：接口类型，用于规范各个产品的组成部分；  具体建造者ConcreteBuilder：实现Builder中的所有方法，返回一个产品实例；  指导者Director：指挥建造者制造相应的产品  产品Product：用户最终看到的复杂对象。
假设我们有一个向客户发送新年祝福邮件的需求，而邮件内容可以是纯文档的，也可以是有动画的，也可以是有音频的，可以动态的添加个组件
uml下图所示： 如上图所示，邮箱有多个组件，包含收件人，发送人，内容，音乐等 通过具体的建造者添加不同的组件模版，最后通过指挥者去调用抽象建造者 来返回具体的email对象
代码如下 ==================product======================
public interface Module { String showInfo(String info); }` public abstract class CommonModule implements Module { protected String moduleName; protected String productionTime() { return Optional.ofNullable(moduleName).orElse(&amp;quot;&amp;quot;) + &amp;quot;--&amp;gt; createTime : &amp;quot; + LocalDate.now().toString(); } } public class Sender extends CommonModule{ public Sender() { super.moduleName = &amp;quot;发件人&amp;quot;; } @Override public String showInfo(String info) { return Optional.ofNullable(info).orElse(&amp;quot;sender : nicky@qq.</description>
    </item>
    
    <item>
      <title>设计模式之factory模式</title>
      <link>https://nicky-chin.cn/2017/12/07/builder-factory/</link>
      <pubDate>Thu, 07 Dec 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/12/07/builder-factory/</guid>
      <description>定义：工厂模式通俗意义上讲就是一个多产品的流程化工厂，每个工厂生产同一系列相关性的组件
分类：
按工厂职能划分可以分为三类：  简单工厂模式（Simple Factory）  工厂方法模式（Factory Method）  抽象工厂方法（Abstract Factory）
接下来我们直接通过uml图和具体的代码实现以上三类
我们以汽车工厂生产汽车为例，本田工厂假设要生产CIVIC和CRV两种车型，那么我们该怎么去设计实现
1 简单工厂模式
工厂产品线流程如上图所示：工厂生产汽车通过指定汽车的编号，我们就可以走指定的产品线；调用者只需要选择具体车型而不需要内部车是怎么制造出来的
简单工厂模式主要包括三部分： 工厂角色：上图中的HONDAFactroy 生产车型用 抽象产品角色：上图中的HONDA和HONDACar 包含通用的属性和方法 具体产品角色：上图中的CIVIC和CRV，具体的车型包含各种参数
代码如下
/** * @author nicky_chin [shuilianpiying@163.com] * @since –created on 2017/12/27 at 11:11 */ public class CIVIC extends HONDACar implements HONDA { private String carName; private Double price; public CIVIC() { this.carName = &amp;quot;10代思域&amp;quot;; this.price = 158000.9; } @Override public String introduceCar() { return &amp;quot;CIVIC{&amp;quot; + &amp;quot;carName=&#39;&amp;quot; + carName + &#39;\&#39;&#39; + &amp;quot;, price=&amp;quot; + price + &amp;quot;} &amp;quot; + super.</description>
    </item>
    
    <item>
      <title>可重入锁</title>
      <link>https://nicky-chin.cn/2017/11/03/recursive-lock/</link>
      <pubDate>Fri, 03 Nov 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/11/03/recursive-lock/</guid>
      <description>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。比如ReentrantLock 和synchronized 都是 可重入锁
直接放代码
 public class SubService { ReentrantLock lock = new ReentrantLock(); public void subService1() { lock.lock(); System.out.println(&amp;quot;thread = &amp;quot; + Thread.currentThread().getId() + &amp;quot; --subService1&amp;quot;); subService2(); lock.unlock(); } public synchronized void subService2() { System.out.println(&amp;quot;thread = &amp;quot; + Thread.currentThread().getId() + &amp;quot; --subService2&amp;quot;); } } public class Service extends SubService { public synchronized void service1(){ System.out.println(&amp;quot;thread = &amp;quot; + Thread.currentThread().getId() + &amp;quot; --service1&amp;quot;); service2(); } public synchronized void service2() { System.</description>
    </item>
    
    <item>
      <title>库级优化之SHOW GLOBAL STATUS</title>
      <link>https://nicky-chin.cn/2017/09/12/show-global-status/</link>
      <pubDate>Tue, 12 Sep 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/09/12/show-global-status/</guid>
      <description>慢查询
//查询慢线程情况 show global status like &#39;%slow%&#39; +---------------------+-------+ | Variable_name | Value | +---------------------+-------+ | Slow_launch_threads | 1 | | Slow_queries | 100 | +---------------------+-------+ 如果Slow_launch_threads值较大，说明有些东西正在延迟连接的新线程 //查询慢查询日志是否开启 show variables like &#39;%slow%&#39; +---------------------+--------------------------------------+ | Variable_name | Value | +---------------------+--------------------------------------+ |log_slow_admin_statements| ON | |log_slow_slave_statements| OFF | | slow_launch_time | 2 | | slow_query_log | ON | | slow_query_log_file | /home/mysql/mysql/slow_query.log | +---------------------+--------------------------------------+ log_slow_admin_statements表示是否将慢管理语句例如ANALYZE TABLE和ALTER TABLE等记入慢查询日志 log_slow_slave_statements 表示是否管理分区慢查询记录，一般不会去选择分区，所以不考虑  配置中一定要开启慢查询，这对服务器性能损耗并不大，如上面的打印结果得知：超过2秒即为慢查询，一共有100条慢查询 。当然我们在后台也可以做sql拦截记录，定制化慢查询语句。通常，可以通过mybatis插件拦截耗时sql打印日志
连接数
//mysql的最大连接数 show global status like &#39;max_connections&#39;; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 500 | +-----------------+-------+ 常见的问题&amp;quot;MYSQL: ERROR 1040: Too many connections&amp;quot;的异常情况，造成这种情况的一种原因是用户访问量过高, MySQL服务器抗不住也有可能是最大连接数设置的过小，需要注意 //服务器响应的最大连接数 show global status like &#39;max_used_connections&#39;; +----------------------+-------+ | Variable_name | Value | +----------------------+-------+ | Max_used_connections | 450 | +----------------------+-------+  设置的最大连接数是500，而响应的连接数是498，max_used_connections / max_connections * 100% = 90% （理想值 ≈ 85%）。</description>
    </item>
    
    <item>
      <title>后端开发需要了解的mysql优化方向</title>
      <link>https://nicky-chin.cn/2017/06/13/optimize-picture/</link>
      <pubDate>Tue, 13 Jun 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/06/13/optimize-picture/</guid>
      <description>#优化思维导图 #参数优化注意事项 参数优化分为 动态参数配置 和 配置文件的配置，建议在启动mysql之前配置好优化参数，这样将会全局有效，如使用动态参数配置可能会不生效或出现问题,并且如果数据库重启那么之前的优化参数都会失效
SHOW VARIABLES LIKE &#39;sort%&#39; 修改会话级变量 set SESSION sort_buffer_size=720000 退出重新连接后，此参数恢复原值 修改全局变量 set GLOBAL sort_buffer_size = 720000  #优化系列 库级优化之SHOW GLOBAL STATUS</description>
    </item>
    
    <item>
      <title>多线程之线程通信摘要</title>
      <link>https://nicky-chin.cn/2017/05/16/thread-communication/</link>
      <pubDate>Tue, 16 May 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/05/16/thread-communication/</guid>
      <description>首先我们要知道进程之间的通讯方式有哪些？
管道( pipe ) #消息队列( message queue ) #共享内存( shared memory ) ：#套接字( socket ) 等等&amp;ndash; 线程的通讯方式：
1 wait/notify 机制 wait()方法和notify()方法是Object类提供的方法，而在使用的条件就是当前线程必须有自己的监听器
否则就是抛出异常，我们可以使用jvm提供的内置锁 synchronized 关键字来配合使用；注意如果有多个
线程等待，当某一线程发起唤醒操作，会随机唤醒一个线程，而非所有线程，如果想唤醒所有线程，可以使用
notifyAll()方法
下面是 启动一个等待线程和一个通知线程的例子
public class MyThread1 extends Thread { private Object lock; public MyThread1(Object lock) { this.lock = lock; } @Override public void run() { try { synchronized (lock) { System.out.println(&amp;quot;wait start time = &amp;quot; + System.currentTimeMillis()); lock.wait(); System.out.println(&amp;quot;wait end time = &amp;quot; + System.</description>
    </item>
    
    <item>
      <title>数据库设计三范式和反范式</title>
      <link>https://nicky-chin.cn/2017/05/07/design-rule/</link>
      <pubDate>Sun, 07 May 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/05/07/design-rule/</guid>
      <description>数据库范式 范式的级别 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 范式越高，冗余最低，一般到三范式，再往上，表越多，可能导致查询效率下降。所以有时为了提高运行效率，可以让数据冗余(反三范式，一般某个数据经常被访问时，比如数据表里存放了语文数学英语成绩，但是如果在某个时间经常要得到它的总分，每次都要进行计算会降低性能，可以加上总分这个冗余字段)。 后面的范式是在满足前面范式的基础上，比如满足第二范式的一定满足第一范式。 第一范式（1NF）：确保每一列的原子性 如果每一列都是不可再分的最小数据单元，则满足第一范式。 但是具体地址到底要不要拆分 还要看具体情形，比如看看将来会不会按国家或者省市进行分类汇总或者排序，如果需要，最好就拆，如果不需要而仅仅起字符串的作用，可以不拆，操作起来更方便。
第二范式:非键字段必须依赖于键字段 如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键，则满足二范式(2NF)，第二范式要求每个表只描述一件事。例如： 第三范式：在1NF基础上，除了主键以外的其它列都不传递依赖于主键列，或者说： 任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）
例如：上面的表，学号和姓名存在传递依赖，因为(学号，姓名)-&amp;gt;成绩，学号-&amp;gt;成绩，姓名-&amp;gt;成绩。所以学号和姓名有一个冗余了，只需要保留一个。
范式的优点：
 1）范式化的数据库更新起来更加快； 2）范式化之后，只有很少的重复数据，只需要修改更少的数据； 3）范式化的表更小，可以在内存中执行； 4）很少的冗余数据，在查询的时候需要更少的distinct或者group by语句。  范式的缺点：
 范式化的表，在查询的时候经常需要很多join关联,增加让查询的代价  反范式的优点：
 1）可以避免关联，因为所有的数据几乎都可以在一张表上显示； 2）可以设计有效的索引；  反范式的缺点：
表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失。  所以在设计数据库时，要注意混用范式化和反范式化。</description>
    </item>
    
    <item>
      <title>自定义序列化之Externalizable接口</title>
      <link>https://nicky-chin.cn/2017/01/23/externalizable-interface/</link>
      <pubDate>Mon, 23 Jan 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/01/23/externalizable-interface/</guid>
      <description>Externalizable简介 Externalizable是一种优先级要高于 Serializable 的序列化机制接口， 这个接口提供了writeExternal()和readExternal()方法用于指定序列化哪些属性。
Externalizable接口与Serializable接口区别 * 1 Serializable序列化时不会调用默认的构造器，而Externalizable序列化时会调用默认构造器 * 2 transient关键字对Externalizable无效
代码事例
公共抽象实体类AbstractDO
public abstract class AbstractDO implements Externalizable { private static final long serialVersionUID = -1679770357930200297L; private Long id; private Date createTime; private Date updateTime; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } public Date getUpdateTime() { return updateTime; } public void setUpdateTime(Date updateTime) { this.</description>
    </item>
    
    <item>
      <title>技术图谱</title>
      <link>https://nicky-chin.cn/2018/06/17/architect/</link>
      <pubDate>Sun, 17 Jun 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2018/06/17/architect/</guid>
      <description>《后端架构师技术图谱》 数据结构 队列  《java队列——queue详细分析》
 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。  《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》
  集合  《Java Set集合的详解》  链表、数组  《Java集合详解&amp;ndash;什么是List》  字典、关联数组  《Java map 详解 - 用法、遍历、排序、常用API等》  栈  《java数据结构与算法之栈（Stack）设计与实现》 《Java Stack 类》 《java stack的详细实现分析》  Stack 是线程安全的。 内部使用数组保存数据，不够时翻倍。   树 二叉树 每个节点最多有两个叶子节点。 * 《二叉树》
完全二叉树  《完全二叉树》  叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。   平衡二叉树 左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 * 《浅谈数据结构-平衡二叉树》 * 《浅谈算法和数据结构: 八 平衡查找树之2-3树》
二叉查找树（BST） 二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</description>
    </item>
    
    <item>
      <title>阅读书单</title>
      <link>https://nicky-chin.cn/2017/03/17/book_list/</link>
      <pubDate>Fri, 17 Mar 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/03/17/book_list/</guid>
      <description>1 并发编程相关
 《Java多线程编程核心技术》 《Java并发编程从入门到精通》 《Java并发编程的艺术》 《Java 并发编程实战》 《深入理解 Java 内存模型》 《实战Java高并发程序设计》   2 MYSQL相关
 《Mysql-5.7官方文档》 《高性能MySQL 第3版》 《数据库索引设计与优化》 《数据库查询优化器的艺术》 《MySQL排错指南》 《MySQL技术内幕：InnoDB存储引擎1~2卷》   3 算法相关
 《Java数据结构和算法》 《IT名企算法与数据结构题目最优解》 《从PAXOS到ZOOKEEPER分布式一致性原理与实践》   4 分布式和架构
 《分布式Java应用基础与实践》 《大型网站系统与Java中间件实践》 《分布式服务架构：原理、设计与实战》 《可伸缩服务架构:框架与中间件》 《构建高性能web站点》 《大型网站技术架构：核心原理与案例分析》 《亿级流量网站架构核心技术》   5 缓存相关
 《redis设计与实现(第二版)》 《深入分布式缓存》 《REDIS开发与运维》   6 JVM虚拟机
 《Java虚拟机（第二版）》 《自己动手写Java虚拟机》   7 Java Web
 《深入分析Java Web技术内幕》 《Spring源码深度解析》 《SPRING技术内幕》   8 其他</description>
    </item>
    
    <item>
      <title>在线工具</title>
      <link>https://nicky-chin.cn/2017/02/19/tools/</link>
      <pubDate>Sun, 19 Feb 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/02/19/tools/</guid>
      <description>cron定时任务表达式
编码格式转换
JVM参数调优
apache镜像
java源码搜索
JSON在线解析
谷歌市场国外软件下载
PYPI
Python-Package
正则代码生成
RGB颜色参考
在线格式转换
sitemap自动生成
markdown转公众号文章
加密解密工具</description>
    </item>
    
    <item>
      <title>开源项目</title>
      <link>https://nicky-chin.cn/2017/02/19/open_source/</link>
      <pubDate>Sun, 19 Feb 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/02/19/open_source/</guid>
      <description>待续。。。。。。</description>
    </item>
    
    <item>
      <title>联系&amp;留言</title>
      <link>https://nicky-chin.cn/2017/02/19/info/</link>
      <pubDate>Sun, 19 Feb 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chin.cn/2017/02/19/info/</guid>
      <description> 联系方式  e-mail: shuilianpiying@163.com
qq: 1529274926
 </description>
    </item>
    
  </channel>
</rss>