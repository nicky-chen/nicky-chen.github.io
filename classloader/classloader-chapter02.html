<!DOCTYPE html>
<html lang="zh">
<head>

        <title>ClassLoader类加载分析（二）</title>
        <meta charset="utf-8" />
        <link href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="南乡清水 RSS Feed" />
        <link href="/feeds/classloader.rss.xml" type="application/rss+xml" rel="alternate" title="南乡清水 Categories RSS Feed" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="/theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="/theme/style.css" />
        <link rel="stylesheet" type="text/css" href="/theme/pygment.css" />
        <link rel="shortcut icon" href="/theme/images/favicon.ico">

        <script src="/theme/js/libs/modernizr-2.6.2.min.js"></script>




</head>

<body id="index" class="home">


    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="/">南乡清水 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>

                <ul class="columns">
                    <li><a href="/">Home</a></li>

                    <li
><a href="/yue-du-shu-dan.html">阅读书单</a></li>
                    <li
><a href="/zai-xian-gong-ju.html">在线工具</a></li>
                    <li
><a href="/kai-yuan-xiang-mu.html">开源项目</a></li>
                    <li
><a href="/guan-yu-wo.html">关于我</a></li>
                     <li><a href="/archives.html"><i class="active"></i>归档日志</a></li>
                    <form class="navbar-search pull-right" action="/search.html">
                        <input type="text" class="search-query" placeholder="站内搜" name="q" id="s">
                    </form>
                </ul>
            </div>

<section id="content" class="body">

   <div class="row">
        <div class="eleven columns">


            <header>
              <h2 class="entry-title">
                <a href="/classloader/classloader-chapter02.html" rel="bookmark"
                   title="Permalink to ClassLoader类加载分析（二）">ClassLoader类加载分析（二）</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2018-03-20T22:48:00+08:00">
                周二 20 三月 2018
              </abbr>
              <address class="vcard author">By 
                <a class="url fn" href="/author/nicky_chin.html"> nicky_chin</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <h1>一、JVM 提供的 Classloader</h1>
<h2>1.1 BootstrapClassloader</h2>
<p>引导类加载器，又称启动类加载器，是最顶层的类加载器，主要用来加载Java核心类，如rt.jar、resources.jar、charsets.jar等，Sun的JVM中，执行java的命令中使用<strong>-Xbootclasspath选项或使用- D选项</strong>指定sun.boot.class.path系统属性值可以指定附加的类，它不是 java.lang.ClassLoader的子类，而是由JVM自身实现的该类c 语言实现，Java程序访问不到该加载器。通过下面代码可以查看该加载器加载了哪些jar包</p>
<div class="highlight"><pre><span></span><span class="nt">public</span> <span class="nt">class</span> <span class="nt">MainClass</span> <span class="p">{</span>

    <span class="err">public</span> <span class="err">static</span> <span class="err">void</span> <span class="err">main(String</span><span class="cp">[]</span> <span class="err">args)</span> <span class="err">throws</span> <span class="err">ClassNotFoundException</span> <span class="err">{</span>
        <span class="err">URL</span><span class="cp">[]</span> <span class="err">urls</span> <span class="err">=</span> <span class="err">sun.misc.Launcher.getBootstrapClassPath().getURLs()</span><span class="p">;</span>
        <span class="err">Arrays.stream(urls).map(</span><span class="n">URL</span><span class="p">:</span><span class="o">:</span><span class="n">toExternalForm</span><span class="p">)</span><span class="o">.</span><span class="nf">forEach</span><span class="p">(</span><span class="n">System</span><span class="err">.</span><span class="n">out</span><span class="err">::</span><span class="n">println</span><span class="p">);</span>
    <span class="p">}</span>

<span class="err">}</span>
</pre></div>


<p>执行结果：
file:/C:/java/jdk1.8.0_74/jre/lib/resources.jar
file:/C:/java/jdk1.8.0_74/jre/lib/rt.jar
file:/C:/java/jdk1.8.0_74/jre/lib/sunrsasign.jar
file:/C:/java/jdk1.8.0_74/jre/lib/jsse.jar
file:/C:/java/jdk1.8.0_74/jre/lib/jce.jar
file:/C:/java/jdk1.8.0_74/jre/lib/charsets.jar
file:/C:/java/jdk1.8.0_74/jre/lib/jfr.jar
file:/C:/java/jdk1.8.0_74/jre/classes，
写到这里大家应该都知道，我们并没有在classpath里面指定这些类的路径，为啥还是能被加载到jvm并使用起来了吧，因为这些是bootstarp来加载的。</p>
<h2>1.2 ExtClassloader</h2>
<p>扩展类加载器，主要负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar包或者<strong>由java.ext.dirs系统属性</strong>指定的jar包。放入这个目录下的jar包对所有AppClassloader都是可见的（后面会知道ExtClassloader是AppClassloader的父加载器)。那么ext都是在那些地方加载类内：</p>
<div class="highlight"><pre><span></span>System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));
</pre></div>


<p>C:\java\jdk1.8.0_74\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</p>
<h2>1.3 AppClassloader</h2>
<p>系统类加载器，又称应用加载器，本文说的SystemClassloader和APPClassloader是一个东西，它负责在JVM启动时，加载来自在命令java中的-classpath或者<strong>java.class.path系统属性或者 CLASSPATH</strong>操作系统属性所指定的JAR类包和类路径。调用ClassLoader.getSystemClassLoader()可以获取该类加载器。如果没有特别指定，则用户自定义的任何类加载器都将该类加载器作为它的父加载器,这点通过ClassLoader的无参构造函数可以知道如下：</p>
<div class="highlight"><pre><span></span> protected ClassLoader() {        this(checkCreateClassLoader(), getSystemClassLoader());
    }
</pre></div>


<p>执行以下代码即可获得classpath加载路径：</p>
<div class="highlight"><pre><span></span>System.out.println(System.getProperty(&quot;java.class.path&quot;));
</pre></div>


<h2>1.4 Java中如何构造三种类加载器的结构</h2>
<p>下面从源码来分析下JVM是如何构建内置classloader的，具体是rt.jar包里面sun.misc.Launcher类：</p>
<div class="highlight"><pre><span></span>public class Launcher {

private static Launcher launcher = new Launcher();
    private static String bootClassPath =
        System.getProperty(&quot;sun.boot.class.path&quot;);

    public static Launcher getLauncher() {
        return launcher;
    }

    private ClassLoader loader;
public Launcher()  
      {  
        ExtClassLoader localExtClassLoader;  
        try  
        {  //首先创建了ExtClassLoader
          localExtClassLoader = ExtClassLoader.getExtClassLoader();  
        }  
        catch (IOException localIOException1)  
        {  
          throw new InternalError(&quot;Could not create extension class loader&quot;);  
        }  
        try  
        {  //然后以ExtClassloader作为父加载器创建了AppClassLoader
          this.loader = AppClassLoader.getAppClassLoader(localExtClassLoader);  
        }  
        catch (IOException localIOException2)  
        {  
          throw new InternalError(&quot;Could not create application class loader&quot;);  
        }  //这个是个特殊的加载器后面会讲到，这里只需要知道默认下线程上下文加载器为appclassloader
        Thread.currentThread().setContextClassLoader(this.loader);  

        ................
      }
</pre></div>


<ol>
<li>Launcher初始化了ExtClassLoader和AppClassLoader。 </li>
<li>Launcher中并没有看见BootstrapClassLoader，但通过System.getProperty("sun.boot.class.path")得到了字符串bootClassPath,这个应该就是BootstrapClassLoader加载的jar包路径。</li>
</ol>
<p>下面看下ExtClassLoader.getExtClassLoader()的代码</p>
<div class="highlight"><pre><span></span>static class ExtClassLoader extends URLClassLoader {

        static {
            ClassLoader.registerAsParallelCapable();
        }

public static ExtClassLoader getExtClassLoader()  
      throws IOException  
    {  //可以知道ExtClassLoader类加载路径为java.ext.dirs
      File[] arrayOfFile = getExtDirs();  
      try  
      {  
        (ExtClassLoader)AccessController.doPrivileged(new PrivilegedExceptionAction()  
        {  
          public Launcher.ExtClassLoader run()  
            throws IOException  
          {  
            int i = this.val$dirs.length;  
            for (int j = 0; j &lt; i; j++) {  
              MetaIndex.registerDirectory(this.val$dirs[j]);  
            }  
            return new Launcher.ExtClassLoader(this.val$dirs);  
          }  
        });  
      }  
      catch (PrivilegedActionException localPrivilegedActionException)  
      {  
        throw ((IOException)localPrivilegedActionException.getException());  
      }  
    }  

    private static File[] getExtDirs()  
    {  
      String str = System.getProperty(&quot;java.ext.dirs&quot;);  
      File[] arrayOfFile;  
      if (str != null)  
      {  
        StringTokenizer localStringTokenizer = new StringTokenizer(str, File.pathSeparator);  

        int i = localStringTokenizer.countTokens();  
        arrayOfFile = new File[i];  
        for (int j = 0; j &lt; i; j++) {  
          arrayOfFile[j] = new File(localStringTokenizer.nextToken());  
        }  
      }  
      else  
      {  
        arrayOfFile = new File[0];  
      }  
      return arrayOfFile;  
    }
</pre></div>


<p>可以指定-D java.ext.dirs参数来添加和改变ExtClassLoader的加载路径。</p>
<p>下面看下AppClassLoader.getAppClassLoader的代码</p>
<div class="highlight"><pre><span></span>public static ClassLoader getAppClassLoader(final ClassLoader paramClassLoader)  
      throws IOException  
    {  //可知AppClassLoader类加载路径为java.class.path
      String str = System.getProperty(&quot;java.class.path&quot;);  
      final File[] arrayOfFile = str == null ? new File[0] : Launcher.getClassPath(str);  

      (ClassLoader)AccessController.doPrivileged(new PrivilegedAction()  
      {  
        public Launcher.AppClassLoader run()  
        {  
          URL[] arrayOfURL = this.val$s == null ? new URL[0] : Launcher.pathToURLs(arrayOfFile);  

          return new Launcher.AppClassLoader(arrayOfURL, paramClassLoader);  
        }  
      });  
    }
</pre></div>


<p>AppClassLoader加载的就是java.class.path下的路径。</p>
<h2>1.5 三种加载器联系</h2>
<p><img alt="jvm类加载器" src="http://upload-images.jianshu.io/upload_images/10175660-90c729d86ec3c812.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>自定义的无参加载器的<strong>父类加载器默认是AppClassloader加载器</strong>，而<strong>AppClassloader加载器的父加载器是ExtClassloader</strong>，我们通过下面代码可以验证：</p>
<div class="highlight"><pre><span></span>public class MainClass {

    public static void main(String[] args) throws ClassNotFoundException {
        System.out.println(ClassLoader.getSystemClassLoader().toString());
        ClassLoader loader = ClassLoader.getSystemClassLoader().getParent();

        ClassLoader classLoader = MainClass.class.getClassLoader();
        System.out.println(&quot;MainClass&#39;s classLoader is &quot; + classLoader.toString());
        System.out.println(&quot;classLoader&#39;s parent is &quot; +classLoader..getParent().toString());

       Class aClass = classLoader.loadClass(&quot;compare.CompareTest&quot;);
        System.err.println(aClass.getClassLoader().toString());
}
}
</pre></div>


<p>结果如下：
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@2a84aee7
MainClass's classLoader is sun.misc.Launcher$AppClassLoader@18b4aac2
classLoader's parent is sun.misc.Launcher$ExtClassLoader@2a84aee7
sun.misc.Launcher$AppClassLoader@18b4aac2
=============================================================
<strong>如上可知 MainClass的类加载器和CompareTest的类加载器指向的都是同一个
AppClassLoader,这是类的默认加载器</strong></p>
<p>一般我们都认为ExtClassloader的父类加载器是BootStarpClassloader，但是其实他们之间根本是没有父子关系的，只是在ExtClassloader找不到要加载类时候会去委托BootStrap加载器去加载。
通过如下代码可以知道父加载器为null</p>
<div class="highlight"><pre><span></span>ClassLoader.getSystemClassLoader().getParent().getParent()
 System.out.println(int.class.getClassLoader().toString());
 //System.out.println(String.class.getClassLoader().toString());
</pre></div>


<p>打印结果：
NPE异常, int基本类型和String类型也无法获取他们的父类
================================================
那么他们到底是怎么被加载的，<strong>答案是BootstrapLoader;Bootstrap ClassLoader是由C++编写的，可以通过通过JNI本地方法调用实现。具体底层代码不做研究，但是可以通过类加载的原理来论证</strong></p>
<h2>1.6 类加载器原理</h2>
<p>Java类加载器使用的是委托机制，也就是子类加载器在加载一个类时候会让父类来加载，那么问题来了，为啥使用这种方式那?因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrap ClassLoader）加载，所以用户<strong>自定义的ClassLoader永远也无法加载一个自己写的同包路径的也就是java.lang.String的类，即时改变JDK中ClassLoader搜索类的默认算法,但还是会报java.lang.SecurityException</strong>， 下面我们从源码看如何实现委托机制：</p>
<p>整个流程可以如下图所示： </p>
<p><img alt="类加载时序图" src="https://upload-images.jianshu.io/upload_images/10175660-c1cc4e8ecca728cf.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>================================================================
上面已经详细介绍了加载过程，但具体为什么是这样加载，我们还需要了解几个个重要的方法loadClass()、findLoadedClass()、findClass()、defineClass()。
类加载过程通过debug调试发现 首先会调用<strong>ClassLoader类中的 getSystemClassLoader()</strong> 然后会进入Launcher类，初始化了ExtClassLoader和AppClassLoader 然后 进入loadclass方法</p>
<div class="highlight"><pre><span></span><span class="kr">protected</span> <span class="nx">Class</span><span class="cp">&lt;?</span><span class="o">&gt;</span> <span class="nx">loadClass</span><span class="p">(</span><span class="nx">Stringname</span><span class="p">,</span><span class="nx">boolean</span> <span class="nx">resolve</span><span class="p">)</span>  
       <span class="nx">throws</span> <span class="nx">ClassNotFoundException</span>  
   <span class="p">{</span>  
       <span class="nx">synchronized</span> <span class="p">(</span><span class="nx">getClassLoadingLock</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span> <span class="p">{</span>  
           <span class="c1">// (1)首先从jvm缓存查找该类 ，检测是否已经加载</span>
           <span class="k">Class</span> <span class="nc">c</span> <span class="o">=</span> <span class="nx">findLoadedClass</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>           
          <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">==</span><span class="k">null</span><span class="p">)</span> <span class="p">{</span>  
               <span class="nx">longt0</span> <span class="o">=</span> <span class="nx">System</span><span class="o">.</span><span class="nx">nanoTime</span><span class="p">();</span>  
               <span class="k">try</span> <span class="p">{</span>  
                   <span class="c1">//然后委托给父类加载器进行加载</span>
                   <span class="k">if</span> <span class="p">(</span><span class="k">parent</span> <span class="o">!=</span><span class="k">null</span><span class="p">)</span> <span class="p">{</span>  
                      <span class="c1">//父加载器不为空则调用父加载器的loadClass</span>
                       <span class="nx">c</span> <span class="o">=</span> <span class="k">parent</span><span class="o">.</span><span class="nx">loadClass</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="k">false</span><span class="p">);</span>  
                   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
                   <span class="c1">//如果父类加载器为null,则委托给BootStrap加载器加载</span>
                       <span class="nx">c</span> <span class="o">=</span> <span class="nx">findBootstrapClassOrNull</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>  
                   <span class="p">}</span>  
               <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">ClassNotFoundExceptione</span><span class="p">)</span> <span class="p">{</span>  
                   <span class="c1">// ClassNotFoundException thrown if class not found  </span>
                   <span class="c1">// from the non-null parent class loader  </span>
               <span class="p">}</span>  

               <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">==</span><span class="k">null</span><span class="p">)</span> <span class="p">{</span>  
                   <span class="c1">// 若仍然没有找到则调用findclass查找</span>
                   <span class="c1">// to find the class.  </span>
                   <span class="nx">longt1</span> <span class="o">=</span> <span class="nx">System</span><span class="o">.</span><span class="nx">nanoTime</span><span class="p">();</span> 
                 <span class="c1">//父加载器不为空则调用父加载器的loadClass </span>
                   <span class="nx">c</span> <span class="o">=</span> <span class="nx">findClass</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>  
                   <span class="c1">// this is the defining class loader; record the stats  </span>
                   <span class="nx">sun</span><span class="o">.</span><span class="nx">misc</span><span class="o">.</span><span class="nx">PerfCounter</span><span class="o">.</span><span class="nx">getParentDelegationTime</span><span class="p">()</span><span class="o">.</span><span class="nx">addTime</span><span class="p">(</span><span class="nx">t1</span> <span class="o">-</span><span class="nx">t0</span><span class="p">);</span>  
                   <span class="nx">sun</span><span class="o">.</span><span class="nx">misc</span><span class="o">.</span><span class="nx">PerfCounter</span><span class="o">.</span><span class="nx">getFindClassTime</span><span class="p">()</span><span class="o">.</span><span class="nx">addElapsedTimeFrom</span><span class="p">(</span><span class="nx">t1</span><span class="p">);</span>  
                   <span class="nx">sun</span><span class="o">.</span><span class="nx">misc</span><span class="o">.</span><span class="nx">PerfCounter</span><span class="o">.</span><span class="nx">getFindClasses</span><span class="p">()</span><span class="o">.</span><span class="nx">increment</span><span class="p">();</span>  
               <span class="p">}</span>  
           <span class="p">}</span>  
           <span class="k">if</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">{</span>  
               <span class="c1">//调用resolveClass()</span>
               <span class="nx">resolveClass</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>  
           <span class="p">}</span>  
           <span class="k">return</span> <span class="nx">c</span><span class="p">;</span>  
       <span class="p">}</span>  
   <span class="p">}</span>
</pre></div>


<p>分析代码知道首先会执行
（1）从jvm缓存查找该类，如何该类之前被加载过，则直接从jvm缓存返回该类，否者看当前类加载器是否有父加载器，如果有的话则委托为父类加载器进行加在
（2）递归调用父类加载器，如果ExtClassLoader也没有加载过，则委托为BootStrapClassloader进行加载，如果还是没有找到，则调用当前Classloader的findclass（String）方法进行查找。
（3）参数resolve又是true的话，那么loadClass()又会调用resolveClass(Class)这个方法来生成最终的Class对象</p>
<p>总结下Java应用启动过程是首先BootstarpClassloader加载rt.jar包里面的sun.misc.Launcher类，而该类内部使用BootstarpClassloader加载器构建和初始化Java中三种类加载和线程上下文类加载器，然后在根据不同场景去使载器去自己的类查找路径去加载类。</p>
<h2>1.7 自定义ClassLoader 动态加载class</h2>
<p>可以通过覆盖ClassLoader的findClass方法或者覆盖loadClass方法来实现。</p>
<div class="highlight"><pre><span></span>public class ProxyDriver extends RealDriver implements Driver {

    @Override
    public void driveCar() {
        System.out.println(&quot;帮客户加满油&quot;);
    }

}

public class RealDriver{

    public void say() {
        System.out.println(&quot;say : &quot; + Instant.now().toEpochMilli());

    }
}

public interface Driver {

    void driveCar();

}
</pre></div>


<p>1通过覆盖 loadClass方法</p>
<div class="highlight"><pre><span></span><span class="nt">public</span> <span class="nt">class</span> <span class="nt">MyClassLoader</span> <span class="nt">extends</span> <span class="nt">ClassLoader</span> <span class="p">{</span>

    <span class="err">public</span> <span class="err">MyClassLoader(ClassLoader</span> <span class="err">parent)</span> <span class="err">{</span>
        <span class="err">super(parent)</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">@</span><span class="k">Override</span> 
    <span class="nt">public</span> <span class="nt">Class</span> <span class="nt">loadClass</span><span class="o">(</span><span class="nt">String</span> <span class="nt">name</span><span class="o">)</span> <span class="nt">throws</span> <span class="nt">ClassNotFoundException</span> <span class="p">{</span>

        <span class="nt">if</span> <span class="o">(!</span><span class="s2">&quot;classloader.ProxyDriver&quot;</span><span class="p">.</span><span class="nc">equals</span><span class="o">(</span><span class="nt">name</span><span class="o">))</span> <span class="p">{</span>
            <span class="err">return</span> <span class="err">super.loadClass(name)</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nt">try</span> <span class="p">{</span>

            <span class="err">String</span> <span class="err">path</span> <span class="err">=</span> <span class="err">&quot;</span><span class="n">E</span><span class="p">:</span><span class="o">/</span><span class="n">totalpalce</span><span class="o">/</span><span class="n">excelTest</span><span class="o">/</span><span class="n">target</span><span class="o">/</span><span class="n">classes</span><span class="o">/</span><span class="n">classloader</span><span class="o">/</span><span class="n">ProxyDriver</span><span class="o">.</span><span class="n">class</span><span class="s2">&quot;;</span>

<span class="s2">            byte</span><span class="cp">[]</span><span class="s2"> classData = Files.readAllBytes(Paths.get(path));</span>

<span class="s2">            return defineClass(&quot;</span><span class="n">classloader</span><span class="o">.</span><span class="n">ProxyDriver</span><span class="s2">&quot;, classData, 0, classData.length);</span>

<span class="s2">        } catch (IOException e) {</span>
<span class="s2">            e.printStackTrace();</span>
<span class="s2">        }</span>

<span class="s2">        return null;</span>

<span class="s2">    }</span>

<span class="s2">    public static void main(String</span><span class="cp">[]</span><span class="s2"> args)</span>
<span class="s2">            throws ClassNotFoundException, IllegalAccessException, InstantiationException {</span>

<span class="s2">        //类加载</span>
<span class="s2">        ClassLoader parentClassLoader = MyClassLoader.class.getClassLoader();</span>
<span class="s2">        MyClassLoader classLoader = new MyClassLoader(parentClassLoader);</span>
<span class="s2">        Class myObjectClass = classLoader.loadClass(&quot;</span><span class="n">classloader</span><span class="o">.</span><span class="n">ProxyDriver</span><span class="s2">&quot;);</span>

<span class="s2">        Driver object1 = (Driver) myObjectClass.newInstance();</span>
<span class="s2">        object1.driveCar();</span>

<span class="s2">        RealDriver object2 = (RealDriver) myObjectClass.newInstance();</span>
<span class="s2">        object2.say();</span>

<span class="s2">        //类重载</span>
<span class="s2">        classLoader = new MyClassLoader(parentClassLoader);</span>

<span class="s2">        myObjectClass = classLoader.loadClass(&quot;</span><span class="n">classloader</span><span class="o">.</span><span class="n">ProxyDriver</span><span class="err">&quot;</span><span class="p">);</span>

        <span class="err">object1</span> <span class="err">=</span> <span class="err">(Driver)</span> <span class="err">myObjectClass.newInstance()</span><span class="p">;</span>
        <span class="err">object1.driveCar()</span><span class="p">;</span>

        <span class="err">object2</span> <span class="err">=</span> <span class="err">(RealDriver)</span> <span class="err">myObjectClass.newInstance()</span><span class="p">;</span>
        <span class="err">object2.say()</span><span class="p">;</span>

    <span class="p">}</span>
</pre></div>


<p>2 通过findClass()</p>
<div class="highlight"><pre><span></span><span class="kr">public</span> <span class="kr">class</span> <span class="nx">PathClassLoader</span> <span class="kr">extends</span> <span class="nx">ClassLoader</span> <span class="p">{</span>

   <span class="c1">//要创建用户自己的类加载器，只需要继承java.lang.ClassLoader类，然后覆盖它的findClass(String name)方法即可，即指明如何获取类的字节码流。</span>

    <span class="c1">//如果要符合双亲委派规范，则重写findClass方法（用户自定义类加载逻辑）；要破坏的话，重写loadClass方法(双亲委派的具体逻辑实现)</span>

    <span class="kr">private</span> <span class="nb">String</span> <span class="nx">classPath</span><span class="p">;</span>

    <span class="kr">public</span> <span class="nx">PathClassLoader</span><span class="p">(</span><span class="nb">String</span> <span class="nx">classPath</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">classPath</span> <span class="o">=</span> <span class="nx">classPath</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="err">@</span><span class="nx">Override</span>
    <span class="kr">protected</span> <span class="nx">Class</span><span class="cp">&lt;?</span><span class="o">&gt;</span> <span class="nx">findClass</span><span class="p">(</span><span class="nx">String</span> <span class="nx">name</span><span class="p">)</span> <span class="nx">throws</span> <span class="nx">ClassNotFoundException</span> <span class="p">{</span>
        <span class="nx">System</span><span class="o">.</span><span class="nx">out</span><span class="o">.</span><span class="nx">println</span><span class="p">(</span><span class="s2">&quot;---------&quot;</span><span class="p">);</span>
        <span class="nx">byte</span><span class="p">[]</span> <span class="nx">classData</span> <span class="o">=</span> <span class="nx">getData</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">classData</span> <span class="o">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">ClassNotFoundException</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">defineClass</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">classData</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">classData</span><span class="o">.</span><span class="nx">length</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">byte</span><span class="p">[]</span> <span class="nx">getData</span><span class="p">(</span><span class="nx">String</span> <span class="nx">className</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">String</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">classPath</span> <span class="o">+</span> <span class="nx">File</span><span class="o">.</span><span class="nx">separatorChar</span> <span class="o">+</span> <span class="nx">className</span><span class="o">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="nx">File</span><span class="o">.</span><span class="nx">separatorChar</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.class&quot;</span><span class="p">;</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">Files</span><span class="o">.</span><span class="nx">readAllBytes</span><span class="p">(</span><span class="nx">Paths</span><span class="o">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">IOException</span> <span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">e</span><span class="o">.</span><span class="nx">printStackTrace</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="nx">void</span> <span class="nx">main</span><span class="p">(</span><span class="nx">String</span> <span class="nx">args</span><span class="p">[])</span> <span class="nx">throws</span> <span class="nx">ClassNotFoundException</span><span class="p">,</span> <span class="nx">InstantiationException</span><span class="p">,</span> <span class="nx">IllegalAccessException</span> <span class="p">{</span>
        <span class="nx">PathClassLoader</span> <span class="nx">pcl</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PathClassLoader</span><span class="p">(</span><span class="s2">&quot;E:</span><span class="se">\\</span><span class="s2">totalpalce</span><span class="se">\\</span><span class="s2">excelTest</span><span class="se">\\</span><span class="s2">target</span><span class="se">\\</span><span class="s2">classes&quot;</span><span class="p">);</span>
        <span class="k">Class</span> <span class="nc">c</span> <span class="o">=</span> <span class="nx">pcl</span><span class="o">.</span><span class="nx">findClass</span><span class="p">(</span><span class="s2">&quot;compare.CompareTest&quot;</span><span class="p">);</span><span class="c1">//注意要包括包名</span>
        <span class="nx">System</span><span class="o">.</span><span class="nx">out</span><span class="o">.</span><span class="nx">println</span><span class="p">(</span><span class="nx">c</span><span class="o">.</span><span class="nx">newInstance</span><span class="p">());</span><span class="c1">//打印类加载成功.</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>


<p>建议使用findClass()方法。这用不会破坏类加载的的双亲委托机制</p>
<p>源码地址：http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java</p>
            </div><!-- /.entry-content -->
            <div class="comments">
              <h3>Comments</h3>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
                var disqus_identifier = "classloader/classloader-chapter02.html";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'https://nicky-chen.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
              </script>
            </div>


        </div><!-- /.eleven.columns -->

<div class="three columns">


    <nav class="widget">
        <h4>个人链接</h4>
        <ul class="blank">
            <li><a href="https://stackoverflow.com/users/7444060/nicky-chen">StackOverFlow</a></li>
            <li><a href="https://github.com/nicky-chen">个人GitHub</a></li>
            <li><a href="https://www.jianshu.com/u/c44ed4847c3d">简书博客</a></li>
        </ul>
    </nav>

<h4>专题分类</h4>

 <ul>
     <!---->
     <!---->
     <!---->
     <!--<li><a href="/yue-du-shu-dan.html">阅读书单</a></li>-->
     <!---->
     <!--<li><a href="/zai-xian-gong-ju.html">在线工具</a></li>-->
     <!---->
     <!--<li><a href="/kai-yuan-xiang-mu.html">开源项目</a></li>-->
     <!---->
     <!--<li><a href="/guan-yu-wo.html">关于我</a></li>-->
     <!---->
     <!--<li class="divider-vertical"></li>-->
     <!---->

     <li >
         <a href="/algorithm-datastructure/index.html">
             Algorithm-DataStructure
         </a>
     </li>
     <li class="active" >
         <a href="/classloader/index.html">
             classloader
         </a>
     </li>
     <li >
         <a href="/concurrent/index.html">
             concurrent
         </a>
     </li>
     <li >
         <a href="/design-pattern/index.html">
             design-pattern
         </a>
     </li>
     <li >
         <a href="/distrubuted/index.html">
             distrubuted
         </a>
     </li>
     <li >
         <a href="/java-base/index.html">
             java-base
         </a>
     </li>
     <li >
         <a href="/mysql/index.html">
             MySql
         </a>
     </li>
  </ul>

<!---->
<!--<h4>Categories</h4>-->
<!--<ul class="blank">-->
	<!---->
		<!--<li><a href="/algorithm-datastructure/index.html">Algorithm-DataStructure</a></li>-->
	<!---->
		<!--<li><a href="/classloader/index.html">classloader</a></li>-->
	<!---->
		<!--<li><a href="/concurrent/index.html">concurrent</a></li>-->
	<!---->
		<!--<li><a href="/design-pattern/index.html">design-pattern</a></li>-->
	<!---->
		<!--<li><a href="/distrubuted/index.html">distrubuted</a></li>-->
	<!---->
		<!--<li><a href="/java-base/index.html">java-base</a></li>-->
	<!---->
		<!--<li><a href="/mysql/index.html">MySql</a></li>-->
	<!---->
<!--</ul>-->
<!---->


<h4>标签</h4>
	<ul class="blank">
	    <li class="danger label" ><a href="/tag/li-lun.html">理论</a></li>
	    <li class="danger label" ><a href="/tag/chuang-jian-xing.html">创建型</a></li>
	    <li class="danger label" ><a href="/tag/bing-fa-bian-cheng-si-wei-dao-tu.html">并发编程思维导图</a></li>
	    <li class="danger label" ><a href="/tag/ku-ji-you-hua.html">库级优化</a></li>
	    <li class="danger label" ><a href="/tag/shu-ju-jie-gou.html">数据结构</a></li>
	    <li class="danger label" ><a href="/tag/xing-wei-xing.html">行为型</a></li>
	    <li class="danger label" ><a href="/tag/yuan-ma.html">源码</a></li>
	    <li class="danger label" ><a href="/tag/jie-gou-xing.html">结构型</a></li>
	    <li class="danger label" ><a href="/tag/ji-chu.html">基础</a></li>
	    <li class="danger label" ><a href="/tag/mysqlsi-wei-dao-tu.html">mysql思维导图</a></li>
	    <li class="danger label" ><a href="/tag/suo-you-hua.html">锁优化</a></li>
</ul>



<!---->
<!--<nav class="widget">-->
  <!--<h4>Social</h4>-->
  <!--<ul class="blank">-->
  <!---->
    <!--<li><a href="http://jm.taobao.org/">阿里中间件团队博客</a></li>-->
  <!---->
    <!--<li><a href="http://www.spring4all.com/">Spring中文社区</a></li>-->
  <!---->
    <!--<li><a href="https://github.com/alibaba">alibaba开源项目</a></li>-->
  <!---->
    <!--<li><a href="https://github.com/google">google开源项目</a></li>-->
  <!---->
  <!--</ul>-->
<!--</nav>-->
<!---->


</div> </div><!-- /.row -->
  <div class="pagination">★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆★✪☆
      <ul>
        <li class="prev"><a href="/java-base/introspector.html">Next →</a></li>
        <li><a href="/archives.html">博客导航</a></li>
        <li class="next"><a href="/java-base/binary-operation.html">← Previous</a></li>
      </ul>
    </div>

    <h4>相关文章推荐</h4>
    <ul>
        <li><a href="/classloader/classloader-chapter01.html">ClassLoader类加载分析（一）</a></li>
    </ul>


</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">



                   <address id="about" class="vcard body">
                       <br>
                       <nav class="widget">
                           <h4>推荐博客</h4>
                           <ul class="blank">
                               <li><a href="http://jm.taobao.org/">阿里中间件团队博客</a></li>
                               <li><a href="http://www.spring4all.com/">Spring中文社区</a></li>
                               <li><a href="https://github.com/alibaba">alibaba开源项目</a></li>
                               <li><a href="https://github.com/google">google开源项目</a></li>
                           </ul>
                       </nav>
                       <br/>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">





              </ul>
            </div>
          </div>
        </footer>

    </div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
	var pageTracker = _gat._getTracker("UA-119892182-1");
pageTracker._trackPageview();
} catch(err) {}</script>
<script type="text/javascript">
    var disqus_shortname = 'nicky-chen';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
  <script src="/theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="/theme/js/libs/gumby.min.js"></script>
  <script src="/theme/js/plugins.js"></script>
    <script>
        (function () {
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>
</body>
</html>