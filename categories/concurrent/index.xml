<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Concurrent on 南乡清水</title>
    <link>https://nicky-chen.github.io/categories/concurrent/</link>
    <description>Recent content in Concurrent on 南乡清水</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved - 2018</copyright>
    <lastBuildDate>Thu, 09 Aug 2018 11:18:15 +0800</lastBuildDate>
    
	<atom:link href="https://nicky-chen.github.io/categories/concurrent/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>并发基础之Condition(等待队列)</title>
      <link>https://nicky-chen.github.io/2018/08/09/aqs-condition/</link>
      <pubDate>Thu, 09 Aug 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2018/08/09/aqs-condition/</guid>
      <description>1 定义 Condition是在AQS中配合使用的wait/nofity线程通信协调工具类，我们可以称之为等待队列
Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是调用Lock对象的newCondition()方法创建出来的，换句话说，Condition是依赖Lock对象。
Condition与Object中监视器方法不同点 &amp;gt;condition可以有多个等待队列 monitor只有一个队列在对象头中 condition的等待可以自定义超时时间 conditon的signal 是唤醒等待队列头部的线程节点， Object的notify是随机唤醒 condition对象的属性对开发者透明
2 Condition使用 demo代码如下
public class MyService { private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void await() { try { lock.lock(); System.out.println(&amp;quot;A&amp;quot;); condition.await(); System.out.println(&amp;quot;B&amp;quot;); } catch (InterruptedException e) { e.printStackTrace(); }finally { lock.unlock(); System.out.println(&amp;quot;锁释放了&amp;quot;); } } public void signal() { try { lock.lock(); condition.signal(); System.out.println(&amp;quot;唤醒时间 ：&amp;quot; + System.currentTimeMillis()); } catch (Exception e) { e.</description>
    </item>
    
    <item>
      <title>并发基础之AQS同步器（二）</title>
      <link>https://nicky-chen.github.io/2018/08/04/aqs_chapter02/</link>
      <pubDate>Sat, 04 Aug 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2018/08/04/aqs_chapter02/</guid>
      <description>在AQS同步器组件原理分析前，我们需要了解同步队列这个概念，了解同步队列中节点的入队和出队的流程，CHL同步队列的由来，可以参考我之前的文章： 并发基础之AQS同步器（一）
1 同步队列 同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态
FIFO队列Node对象的具体实现如下：
static final class Node { static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter; .final boolean isShared() { return nextWaiter == SHARED; } final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() { } Node(Thread thread, Node mode) { this.</description>
    </item>
    
    <item>
      <title>并发基础之AQS同步器（一）</title>
      <link>https://nicky-chen.github.io/2018/07/31/aqs_chapter01/</link>
      <pubDate>Tue, 31 Jul 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2018/07/31/aqs_chapter01/</guid>
      <description>1 AQS同步器 队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。
同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法 &amp;gt;getState() setState(int newState) compareAndSetState(int expect,int update)
来进行操作，因为它们能够保证状态的改变是安全的。这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）
核心操作方式：
场景1：阻塞直到获取指定资源数
场景2：可中断限时等待直到获取指定资源数
场景3：直接尝试获取指定资源数
场景4：释放指定资源数
上述四个步骤又都可以分为 共享（share）操作和独占（exclusive） 操作两种，如果AQS设计的足够好，则所有的容器类只需要控制资源数目、获取的资源量和释放的资源量即可
下图（独占和共享的方法调用）：
acquire用来表示是获取资源数的操作，而release表示用来释放资源数的操作，不带Shared表示是独占的操作。如果我们没有实现红色圆角矩形框的方法却间接调用了，将会抛出著名的UnsupportedOperationException异常。
2 队列同步器的接口 同步器的设计是基于模板方法模式 模板方法将会调用使用者重写的方法 重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。 * getState()：获取当前同步状态。 * setState(int newState)：设置当前同步状态。 * compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。
独占锁操作方法说明如下：
共享锁操作方法如下：
同步器提供的模板方法基本上分为3类： &amp;gt;独占式获取与释放同步状态 共享式获取与释放 同步状态和查询同步队列中的等待线程情况
自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。只有掌握了同步器的工作原理才能更加深入地理解并发包中其他的并发组件
自定义同步组件 :::java public class Mutex implements Lock { public static void main(String[] args) { Mutex mutex = new Mutex(); CountDownLatch latch = new CountDownLatch(1); Test test = new Test(); ExecutorService pool = Executors.</description>
    </item>
    
    <item>
      <title>synchronized实现原理及锁优化</title>
      <link>https://nicky-chen.github.io/2018/05/14/synchronized-principle/</link>
      <pubDate>Mon, 14 May 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2018/05/14/synchronized-principle/</guid>
      <description>1.引言 并发编程中synchronized是重量级锁，但随着JVM1.6对synchronized进行优化后，有些情况下它并不那么重，本文介绍了Java SE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。
2.术语定义 CAS(Compare and Swap): 比较并交换。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。比较是否和给定的数值一致，如果一致则修改，不一致则不修改。
3.同步的基础 Java中的每一个对象都可以作为锁。 对于同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前对象的Class对象。 对于同步方法块，锁是synchonized括号里配置的对象。
我们通过java代码和字节码分析下 java代码如下：
public class SyncTest { private static double a = 1; public synchronized void plusNumber() { a++; } public void minusNumber() { System.out.println(a); synchronized (this) { a--; } } public synchronized static void divide() { a = a / 0.1; } }  解析成字节码指令:
//同步方法 public synchronized void plusNumber(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=4, locals=1, args_size=1 0: getstatic #2 // Field a:D 3: dconst_1 4: dadd 5: putstatic #2 // Field a:D 8: return LineNumberTable: line 12: 0 line 13: 8 //同步块 public void minusNumber(); descriptor: ()V flags: ACC_PUBLIC Code: stack=4, locals=3, args_size=1 0: getstatic #3 // Field java/lang/System.</description>
    </item>
    
    <item>
      <title>JUC知识点总结</title>
      <link>https://nicky-chen.github.io/2018/05/13/juc-tree-info/</link>
      <pubDate>Sun, 13 May 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2018/05/13/juc-tree-info/</guid>
      <description>作为并发的基础，我们需要熟悉掌握JUC相关的知识，才能更好的在实际项目中运用， 下面是整理出来的juc思维导图：
#系列文章 java内存模型之[JMM][重排序][happens-before] volatile关键字原理实现及应用 synchronized实现原理及锁优化 =============不定期更新============================</description>
    </item>
    
    <item>
      <title>volatile关键字原理实现及应用</title>
      <link>https://nicky-chen.github.io/2018/05/04/volatile-feature/</link>
      <pubDate>Fri, 04 May 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2018/05/04/volatile-feature/</guid>
      <description>1.并发编程中的三个概念 在并发编程中, 需要了解线程的三个概念：原子性，可见性，有序性：
1.1.原子性
 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
 一个很经典的例子就是银行账户转账问题：
比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后， 再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。  　同样地反映到并发编程中会出现什么结果呢？
　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？
i = 9;  假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。
1.2.可见性
 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
 举个简单的例子，看下面这段代码：
//线程1执行的代码 int i = 0; i = 10; //线程2执行的代码 j = i;  　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。
　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。
1.3.有序性
 有序性：即程序执行的顺序按照代码的逻辑顺序执行
 举个简单的例子，看下面这段代码：
int i = 0; boolean flag = false; i = 1; //语句1 flag = true; //语句2  　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</description>
    </item>
    
    <item>
      <title>java内存模型之[JMM][重排序][happens-before]</title>
      <link>https://nicky-chen.github.io/2018/04/03/thread-jmm-happens-before/</link>
      <pubDate>Tue, 03 Apr 2018 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2018/04/03/thread-jmm-happens-before/</guid>
      <description>1.并发编程模型的分类 在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同 步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换 信息。在命令式编程中，线程之间的通信机制有两种：*共享内存和消息传递*。 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内 存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状 态，线程之间必须通过明确的发送消息来显式进行通信。 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模 型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之 间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前， 因此同步是隐式进行的。 Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通 信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的 线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。
2.Java 内存模型的抽象 在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共 享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量 （ Local variables ），方法定义参数（java语言规范称之为 formal method parameters ）和异常处理器参数（ exception handler parameters ）不会在线程之间 共享，它们不会有内存可见性问题，也不受内存模型的影响。 Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个 线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了 线程和主内存之间的抽象关系：*线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存 中存储了该线程以读/写共享变量的副本。*本地内存是 JMM 的一个抽象概念，并不 真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 Java内存模型的抽象示意图如下： 从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤： 1. 首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。 2. 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。 下面通过示意图来说明这两个步骤： 如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个 内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放 在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本 地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线 程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变 为了 1。 从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程 必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来 为 java 程序员提供内存可见性保证。</description>
    </item>
    
    <item>
      <title>可重入锁</title>
      <link>https://nicky-chen.github.io/2017/11/03/recursive-lock/</link>
      <pubDate>Fri, 03 Nov 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2017/11/03/recursive-lock/</guid>
      <description>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。比如ReentrantLock 和synchronized 都是 可重入锁
直接放代码
 public class SubService { ReentrantLock lock = new ReentrantLock(); public void subService1() { lock.lock(); System.out.println(&amp;quot;thread = &amp;quot; + Thread.currentThread().getId() + &amp;quot; --subService1&amp;quot;); subService2(); lock.unlock(); } public synchronized void subService2() { System.out.println(&amp;quot;thread = &amp;quot; + Thread.currentThread().getId() + &amp;quot; --subService2&amp;quot;); } } public class Service extends SubService { public synchronized void service1(){ System.out.println(&amp;quot;thread = &amp;quot; + Thread.currentThread().getId() + &amp;quot; --service1&amp;quot;); service2(); } public synchronized void service2() { System.</description>
    </item>
    
    <item>
      <title>多线程之线程通信摘要</title>
      <link>https://nicky-chen.github.io/2017/05/16/thread-communication/</link>
      <pubDate>Tue, 16 May 2017 11:18:15 +0800</pubDate>
      
      <guid>https://nicky-chen.github.io/2017/05/16/thread-communication/</guid>
      <description>首先我们要知道进程之间的通讯方式有哪些？
管道( pipe ) #消息队列( message queue ) #共享内存( shared memory ) ：#套接字( socket ) 等等&amp;ndash; 线程的通讯方式：
1 wait/notify 机制 wait()方法和notify()方法是Object类提供的方法，而在使用的条件就是当前线程必须有自己的监听器
否则就是抛出异常，我们可以使用jvm提供的内置锁 synchronized 关键字来配合使用；注意如果有多个
线程等待，当某一线程发起唤醒操作，会随机唤醒一个线程，而非所有线程，如果想唤醒所有线程，可以使用
notifyAll()方法
下面是 启动一个等待线程和一个通知线程的例子
public class MyThread1 extends Thread { private Object lock; public MyThread1(Object lock) { this.lock = lock; } @Override public void run() { try { synchronized (lock) { System.out.println(&amp;quot;wait start time = &amp;quot; + System.currentTimeMillis()); lock.wait(); System.out.println(&amp;quot;wait end time = &amp;quot; + System.</description>
    </item>
    
  </channel>
</rss>