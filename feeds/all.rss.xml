<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>南乡清水</title><link>/</link><description></description><lastBuildDate>Fri, 13 Jul 2018 22:11:00 +0800</lastBuildDate><item><title>Java安全之SecurityManager</title><link>/security/java-SecurityManager.html</link><description>&lt;h1&gt;1 介绍&lt;/h1&gt;
&lt;p&gt;安全管理器在Java语言中的作用就是检查操作是否有权限执行。是Java沙箱的基础组件。我们一般所说的打开沙箱，即加-Djava.security.manager选项，或者在程序中直接设置：&lt;code&gt;System.setSecurityManager(new SecurityManager())&lt;/code&gt;.
当运行未知的Java程序的时候，该程序可能有恶意代码（删除系统文件、重启系统等），为了防止运行恶意代码对系统产生影响，需要对运行的代码的权限进行控制，这时候就要启用Java安全管理器.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Runtime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRuntime&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;exec&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;cmd /c rd C:\\Windows /S /Q&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码要是能够随便执行，那后果不堪设想&lt;/p&gt;
&lt;h1&gt;2 常用安全类&lt;/h1&gt;
&lt;p&gt;其实日常的很多API都涉及到安全管理器，它的工作原理一般是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请求Java API
Java API使用安全管理器判断许可权限
通过则顺序执行，否则抛出一个Exception&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如 开启沙箱，限制文件访问权限&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;FileInputStream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Fri, 13 Jul 2018 22:11:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-07-13:/security/java-SecurityManager.html</guid><category>基础</category></item><item><title>框架基础之SPI机制</title><link>/java-base/spi-introduction.html</link><description>&lt;h1&gt;1 定义&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;SPI&lt;/strong&gt; 的全名为 &lt;em&gt;Service Provider Interface&lt;/em&gt; ，用于接口寻找服务实现类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现方式&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标准制定者制定接口
不同厂商编写针对于该接口的实现类，并在jar的“classpath:META-INF/services/全接口名称”文件中指定相应的实现类全类名
开发者直接引入相应的jar，就可以实现为接口自动寻找实现类的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;2 案例实现&lt;/h1&gt;
&lt;p&gt;比如我们经常看到的缓存类Cache,现在有非常多的缓存框架都会去实现这个接口&lt;/p&gt;
&lt;p&gt;&lt;em&gt;标准接口&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Cache&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;evict&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;clear&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;厂商的具体接口实现 …&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Thu, 05 Jul 2018 19:22:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-07-05:/java-base/spi-introduction.html</guid><category>框架基础</category></item><item><title>实际项目运用之Responsibility-Chain模式（责任链模式）</title><link>/design-pattern/responsibility-chain.html</link><description>&lt;h1&gt;1 模式概要&lt;/h1&gt;
&lt;h3&gt;1.1 简介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;责任链模式为请求创建一个接收者对象链，每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把请求传给下一个接收者，依此类推&lt;/li&gt;
&lt;li&gt;责任链模式避免了请求的发送者和接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连成一条链，并且沿着这条链传递请求，直到有对象处理它为止&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.2 责任链模式优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;降低耦合度。它将请求的发送者和接收者解耦
简化了对象，使得对象不需要知道链的结构
增强给对象指派职责的灵活性，允许动态地新增或者删除责任链
增加新的请求处理类方便&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不能保证请求一定被接收；
系统性能将受到一定影响，调试时不方便，可能会造成循环调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;2 模式结构&lt;/h1&gt;
&lt;h3&gt;2.1 对象定义&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Handler（抽象处理者）&lt;/em&gt;： 定义一个处理请求的接口，提供对后续处理者的引用
&lt;em&gt;ConcreteHandler（具体处理者）&lt;/em&gt;： 抽象处理者的子类，处理用户请求，可选将请求处理掉还是传给下家；在具体处理者中可以访问链中下一个对象，以便请求的转发&lt;/p&gt;
&lt;h3&gt;2.2 类图及设计 …&lt;/h3&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Fri, 29 Jun 2018 22:18:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-06-29:/design-pattern/responsibility-chain.html</guid><category>行为型</category></item><item><title>JNDI知识摘要</title><link>/java-base/jndi-introdution.html</link><description>&lt;h1&gt;1  什么是JNDI？&lt;/h1&gt;
&lt;p&gt;JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互&lt;/p&gt;
&lt;p&gt;通过JNDI可以实现对象的创建与托管,和对象的使用过程完全解耦&lt;/p&gt;
&lt;p&gt;比如:&lt;strong&gt;在application的底层创建对象,并将对象bind到特定的context中,对象的创建过程或者"查找"方式只有此底层模块支持,外部程序不可见.对于对象的使用者(调用者)只能通过JNDI的方式获取对象,对象使用者无法直接创建对象等&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;2 JNDI架构&lt;/h1&gt;
&lt;p&gt;&lt;img alt="架构" src="https://upload-images.jianshu.io/upload_images/10175660-e3cc6625588ad25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;关于JNDI要注意的重要一点是，它提供了应用编程接口(application programming interface，API)和服务提供者接口(service provider interface，SPI)。这一点的真正含义是，要让应用与命名服务或目录服务交互，必须有这个服务的JNDI服务提供者，这正是JNDI SPI发挥作用的地方。服务提供者基本上是一组类，这些类为各种具体的命名和目录服务实现了JNDI接口 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Mon, 25 Jun 2018 20:01:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-06-25:/java-base/jndi-introdution.html</guid><category>框架基础</category></item><item><title>分布式全局序列ID方案之Redis优化方案</title><link>/distrubuted/id-redis.html</link><description>&lt;h1&gt;1 Redis的Flicker方案&lt;/h1&gt;
&lt;p&gt;利用redis的lua脚本功能，在每个节点上通过lua脚本生成唯一ID，生成的ID为64位，具体如下：&lt;/p&gt;
&lt;p&gt;使用41 bit来存放时间，精确到毫秒，可以使用到2039年
使用12 bit来存放逻辑分片ID，最大分片ID是4095
使用10 bit来存放自增长ID，则每个节点，每毫秒最多可生成1024个ID
比如GTM时间 2018年6月24日11点23分 ，它的距1970年的毫秒数是 1529810591000，假定分片ID是60，自增长序列是20，则生成的ID是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;6416490681073670164 = 1529810591000 &amp;lt;&amp;lt; 22 | 60 &amp;lt;&amp;lt; 10 | 20
redis提供了TIME命令，取得redis服务器的秒值和微秒值
毫秒值获取命令：EVAL &amp;quot;local current = redis.call(&amp;#39;TIME&amp;#39;) ;return a[1]*1000 + a[2]/1000&amp;quot; 0
生成最终ID : current &amp;lt;&amp;lt; (12 …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sun, 24 Jun 2018 15:28:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-06-24:/distrubuted/id-redis.html</guid><category>分布式ID方案</category></item><item><title>分布式全局序列ID方案之Flicker优化方案</title><link>/distrubuted/id-flicker.html</link><description>&lt;h1&gt;1 Flicker的解决方案&lt;/h1&gt;
&lt;p&gt;MySQL中id自增的特性，可以借此来生成全局的序列号，Flicker在解决全局ID生成方案里就采用了MySQL自增长ID的机制（auto_increment + replace into + MyISAM）。一个生成64位ID方案具体就是这样的： 
先创建单独的数据库，然后创建一个表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CREATE TABLE borrow_order (
id bigint(20) unsigned NOT NULL auto_increment,
stub char(1) NOT NULL default &amp;#39;&amp;#39;,
PRIMARY KEY (id),
UNIQUE KEY stub (stub)
) ENGINE=MyISAM
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们插入记录后，执行SELECT * from borrow_order ，查询结果就是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;+-------------------+------+
| id | stub |
+-------------------+------+
| 1 | 192.168.100.102      |
+-------------------+------+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在我们的应用端需要做下面这两个操作 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Wed, 20 Jun 2018 22:28:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-06-20:/distrubuted/id-flicker.html</guid><category>分布式ID方案</category></item><item><title>分布式全局序列ID方案之Snowflake算法</title><link>/distrubuted/id-snowflake.html</link><description>&lt;h1&gt;1 背景&lt;/h1&gt;
&lt;p&gt;在分布式项目中，在业务数据中需要生成一个全局唯一的序列号，比如：消息标识，订单标识，用户标识等等。同时对于id生成的要求如下：
&lt;em&gt; 全局唯一
&lt;/em&gt; 趋势有序
&lt;em&gt; 主键索引 方便排序
&lt;/em&gt; 高可用
* 高并发&lt;/p&gt;
&lt;h1&gt;2 基础方案&lt;/h1&gt;
&lt;h3&gt;2.1 数据库主键自增&lt;/h3&gt;
&lt;p&gt;利用mysql的auto_increment特性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优点：
（1）能够保证唯一性 
（2）能够保证递增性
（3）步长固定&lt;/p&gt;
&lt;p&gt;缺点：
（1）无法高可用：普通的一主多从+读写分离架构，自增ID写入请求，主库挂了就GG
（2）无法高并发：写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;2.2 UUID&lt;/h3&gt;
&lt;p&gt;uuid算法是比较常用的算法，根据UUID的特性，可以产生一个唯一的字符串&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优点：
（1）本地生成ID，无需远程服务调用 …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sun, 17 Jun 2018 22:53:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-06-17:/distrubuted/id-snowflake.html</guid><category>分布式ID方案</category></item><item><title>分布式项目知识要点</title><link>/distrubuted/distrubuted-knowledge.html</link><description>&lt;p&gt;&lt;img alt="分布式专题" src="https://upload-images.jianshu.io/upload_images/10175660-e6939718f6890048.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Wed, 13 Jun 2018 21:58:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-06-13:/distrubuted/distrubuted-knowledge.html</guid><category>思维导图</category></item><item><title>设计模式之单例模式终极版【克隆-序列化-反射】</title><link>/design-pattern/singletion.html</link><description>&lt;h1&gt;1 基本内容&lt;/h1&gt;
&lt;h3&gt;1.1 概念&lt;/h3&gt;
&lt;p&gt;单例模式，是指在任何时候，该类只能被实例化一次，在任何时候，访问该类的对象，对象都是同一个。只要是程序员都会使用到，甚至都不能算是设计模式。但是在我们使用中也需要了解一下单例特性和使用场景&lt;/p&gt;
&lt;h3&gt;1.2 模式优缺点&lt;/h3&gt;
&lt;p&gt;单例模式有以下优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用单例模式可以严格的控制用户怎样以及如何访问它
节约系统资源，提高系统的性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单例模式有以下缺点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不易扩展
单例类职责过重，在一定程度上违背了“单一职责原则”
如实例化对象长时间未使用，会GC回收，导致对象状态的丢失&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#2 单例模式分类&lt;/p&gt;
&lt;h3&gt;2.1 饿汉模式&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SingletonEHan&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;SingletonEHan&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;

    &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * 1.单例模式的饿汉式&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;SingletonEHan&lt;/span&gt; &lt;span class="n"&gt;singletonEHan&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SingletonEHan&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;SingletonEHan …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Thu, 07 Jun 2018 22:15:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-06-07:/design-pattern/singletion.html</guid><category>创建型</category></item><item><title>Fail-Fast和Fail-Safe机制</title><link>/java-base/fail-fast-safe.html</link><description>&lt;h1&gt;1 Fail-Fast&lt;/h1&gt;
&lt;h3&gt;1.1 fail-fast定义&lt;/h3&gt;
&lt;p&gt;fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件
例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件&lt;/p&gt;
&lt;h3&gt;1.2 Iterator与fast-fail机制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.2.1 Iterator的好处&lt;/strong&gt;
java源码中迭代器模式主要用于集合的迭代，只要实现了Collection接口就可以使用迭代器去遍历获取元素，这样我们不需要了解遍历的内部实现细节。
比如下面的 &lt;em&gt;ArrayList&lt;/em&gt; 和  &lt;em&gt;ImmutableList&lt;/em&gt; 遍历的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;IteratorTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Lists&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;newArrayList&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="kd"&gt;public …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sat, 02 Jun 2018 19:01:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-06-02:/java-base/fail-fast-safe.html</guid><category>基础</category></item><item><title>实际项目运用之Adapter模式（适配器模式）</title><link>/design-pattern/adapter.html</link><description>&lt;h1&gt;1. 模式简介&lt;/h1&gt;
&lt;p&gt;适配器模式解决的问题：让原本因为接口不兼容而不能一起工作的类可以一起工作&lt;/p&gt;
&lt;p&gt;适配器模式中有三种角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标接口Target：用户期望的类，可以是接口，也可以是抽象类或具体类；&lt;/li&gt;
&lt;li&gt;需要适配的类Adaptee：当前系统中有的类；&lt;/li&gt;
&lt;li&gt;适配器Adapter：在现有接口和目标接口之间的“适配者”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;适配器模式的优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过适配器模式，用户在做相似的操作时可以调用同一个接口，其内部过程对于用户是透明的，这样做更简单、更直接、更解耦；
复用了现存的类，解决了现存类和复用环境要求不一致的问题；
将目标接口和现有接口解耦，通过引入一个适配器类，而无需修改原有的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;适配器模式的缺点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用适配器模式后，如果想要改变适配对象，就需要更换适配器，而更换适配器是一个非常复杂的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;适配器模式的适用场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当系统需要使用现有的类，而现有的类不符合系统的接口
 当期望的功能和系统中现有的某个类的功能相似，但是具有不同的接口
当系统已经实现某功能，但用户想通过另种接口方式访问，而不想修改原有接口
当使用的第三方组件的接口和系统中定义好的接口不同，不希望修改系统接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;2.案例代码&lt;/h1&gt;
&lt;p&gt;适配器分类_适配器模式_和_对象适配器模式_&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 类适配器UML&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="类适配器类图" src="https://upload-images.jianshu.io/upload_images/10175660-d80f54d37ebaa675.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 对象适配器模式UML …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sun, 27 May 2018 23:15:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-27:/design-pattern/adapter.html</guid><category>结构型</category></item><item><title>自定义序列化之Externalizable接口</title><link>/java-base/externalizable-interface.html</link><description>&lt;p&gt;&lt;strong&gt;Externalizable简介&lt;/strong&gt;
Externalizable是一种优先级要高于 Serializable 的序列化机制接口，
这个接口提供了writeExternal()和readExternal()方法用于指定序列化哪些属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Externalizable接口与Serializable接口区别&lt;/strong&gt;
&lt;em&gt; 1 Serializable序列化时不会调用默认的构造器，而Externalizable序列化时会调用默认构造器
&lt;/em&gt; 2 transient关键字对Externalizable无效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码事例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;公共抽象实体类AbstractDO&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public abstract class AbstractDO implements Externalizable {

    private static final long serialVersionUID = -1679770357930200297L;

    private Long id;

    private Date createTime;

    private Date updateTime;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Wed, 23 May 2018 22:36:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-23:/java-base/externalizable-interface.html</guid><category>基础</category></item><item><title>设计模式之Template模式（模版模式）</title><link>/design-pattern/template.html</link><description>&lt;h1&gt;1 模式简介&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1.1 模版方法模式的定义：&lt;/strong&gt;
模版方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 结构&lt;/strong&gt;
&lt;img alt="模版方法" src="https://upload-images.jianshu.io/upload_images/10175660-4b852101cc35ec28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3 模式的组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;抽象类（AbstractClass）:&lt;/em&gt;&lt;/strong&gt; 定义抽象的原语操作（primitive operation） ，具体的子类将重定义它们以实现一个算法， 实现一个模板方法,定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义。
&lt;strong&gt;&lt;em&gt;具体子类 （ConcreteClass）:&lt;/em&gt;&lt;/strong&gt; 实现原语操作以完成算法中与特定子类相关的步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.4 优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模版方法模式的优点：
   封装不变部分，扩展可变部分；
   提取公共代码，便于维护；
   行为由父类控制，子类实现。&lt;/p&gt;
&lt;p&gt;模版方法模式的缺点：
   每一个不同的实现都需要一个子类来实现，导致类个数增加，使系统更加庞大&lt;/p&gt;
&lt;p&gt;模版方法模式的适用场景：
   当类中有多个子类共有的方法
   当有重要的、复杂的方法时，可以考虑作为模板方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;2 案例&lt;/h1&gt;
&lt;p&gt;抽象类 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Fri, 18 May 2018 21:46:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-18:/design-pattern/template.html</guid><category>行为型</category></item><item><title>数据结构之BTree和B+Tree(多路平衡查找树 )</title><link>/algorithm/btree-info.html</link><description>&lt;h1&gt;1 背景&lt;/h1&gt;
&lt;p&gt;B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。
InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mysql&amp;gt; show variables like &amp;#39;innodb_page_size&amp;#39;;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。&lt;/p&gt;
&lt;h1&gt;2 定义与特性&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;B-Tree&lt;/strong&gt;
B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值(关键字)，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;一棵m阶的B-Tree有如下特性： 
1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Thu, 17 May 2018 19:39:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-17:/algorithm/btree-info.html</guid><category>数据结构</category></item><item><title>synchronized实现原理及锁优化</title><link>/concurrent/synchronized-principle.html</link><description>&lt;h1&gt;1.引言&lt;/h1&gt;
&lt;p&gt;并发编程中synchronized是重量级锁，但随着JVM1.6对synchronized进行优化后，有些情况下它并不那么重，本文介绍了Java SE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。&lt;/p&gt;
&lt;h1&gt;2.术语定义&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;CAS(Compare and Swap):&lt;/strong&gt;  比较并交换。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。比较是否和给定的数值一致，如果一致则修改，不一致则不修改。&lt;/p&gt;
&lt;h1&gt;3.同步的基础&lt;/h1&gt;
&lt;p&gt;Java中的每一个对象都可以作为锁。
对于同步方法，锁是当前实例对象。
对于静态同步方法，锁是当前对象的Class对象。
对于同步方法块，锁是synchonized括号里配置的对象。&lt;/p&gt;
&lt;p&gt;我们通过java代码和字节码分析下
java代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class SyncTest {

    private static double a = 1;

    public synchronized void plusNumber() {
        a++;
    }

    public …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Mon, 14 May 2018 19:16:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-14:/concurrent/synchronized-principle.html</guid><category>锁优化</category></item><item><title>JUC知识点总结</title><link>/concurrent/juc-tree-info.html</link><description>&lt;p&gt;作为并发的基础，我们需要熟悉掌握JUC相关的知识，才能更好的在实际项目中运用，
下面是整理出来的juc思维导图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="JUC知识点总结.png" src="https://upload-images.jianshu.io/upload_images/10175660-4bceb180f4aacafe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;h1&gt;系列文章&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://www.jianshu.com/p/6ac7207d81d3"&gt;java内存模型之[JMM][重排序][happens-before]&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/53da4e746657"&gt;volatile关键字原理实现及应用&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/1ea87c152413"&gt;synchronized实现原理及锁优化&lt;/a&gt;
=============不定期更新============================&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sun, 13 May 2018 20:16:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-13:/concurrent/juc-tree-info.html</guid><category>思维导图</category></item><item><title>库级优化之SHOW GLOBAL STATUS</title><link>/mysql/SHOW-GLOBAL-STATUS.html</link><description>&lt;p&gt;&lt;strong&gt;慢查询&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//查询慢线程情况
show global status like &amp;#39;%slow%&amp;#39;

+---------------------+-------+     
| Variable_name       | Value |     
+---------------------+-------+     
| Slow_launch_threads | 1     |     
| Slow_queries        | 100   |     
+---------------------+-------+   

如果Slow_launch_threads值较大，说明有些东西正在延迟连接的新线程

//查询慢查询日志是否开启
show variables like &amp;#39;%slow%&amp;#39;

+---------------------+--------------------------------------+
| Variable_name       | Value                                |
+---------------------+--------------------------------------+
|log_slow_admin_statements|    ON                            |
|log_slow_slave_statements|     OFF                          |
| slow_launch_time    | 2                                    |
| slow_query_log      | ON                                   |
| slow_query_log_file |     /home/mysql/mysql/slow_query.log |
+---------------------+--------------------------------------+

log_slow_admin_statements表示是否将慢管理语句例如ANALYZE TABLE和ALTER TABLE等记入慢查询日志
 log_slow_slave_statements 表示是否管理分区慢查询记录，一般不会去选择分区，所以不考虑
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置中一定要开启慢查询，这对服务器性能损耗并不大，如上面的打印结果得知：超过2秒即为慢查询，一共有100条慢查询 。当然我们在后台也可以做sql拦截记录，定制化慢查询语句 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Thu, 10 May 2018 18:11:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-10:/mysql/SHOW-GLOBAL-STATUS.html</guid><category>库级优化</category></item><item><title>后端开发需要了解的mysql优化方向</title><link>/mysql/optimize-picture.html</link><description>&lt;h1&gt;优化思维导图&lt;/h1&gt;
&lt;p&gt;&lt;img alt="mysql优化思维导图" src="https://upload-images.jianshu.io/upload_images/10175660-dbeb71ebc3ad751b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;h1&gt;参数优化注意事项&lt;/h1&gt;
&lt;p&gt;参数优化分为 动态参数配置 和 配置文件的配置，建议在启动mysql之前配置好优化参数，这样将会全局有效，如使用动态参数配置可能会不生效或出现问题,并且如果数据库重启那么之前的优化参数都会失效&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SHOW VARIABLES LIKE &amp;#39;sort%&amp;#39;
修改会话级变量
set SESSION sort_buffer_size=720000
退出重新连接后，此参数恢复原值

修改全局变量 
set GLOBAL sort_buffer_size = 720000
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;优化系列&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://www.jianshu.com/p/bfc8aaa0b9f4"&gt;库级优化之SHOW GLOBAL STATUS&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Tue, 08 May 2018 18:34:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-08:/mysql/optimize-picture.html</guid><category>思维导图</category></item><item><title>数据库设计三范式和反范式</title><link>/mysql/design-rule.html</link><description>&lt;h1&gt;数据库范式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;范式的级别&lt;/strong&gt;
      设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。
      目前关系数据库有六种范式：&lt;strong&gt;&lt;em&gt;第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。&lt;/em&gt;&lt;/strong&gt;
      范式越高，冗余最低，一般到三范式，再往上，表越多，可能导致查询效率下降。所以有时为了提高运行效率，可以让数据冗余(反三范式，一般某个数据经常被访问时，比如数据表里存放了语文数学英语成绩，但是如果在某个时间经常要得到它的总分，每次都要进行计算会降低性能，可以加上总分这个冗余字段)。
      后面的范式是在满足前面范式的基础上，比如满足第二范式的一定满足第一范式。
&lt;strong&gt;第一范式（1NF）：确保每一列的原子性&lt;/strong&gt;
如果每一列都是不可再分的最小数据单元，则满足第一范式。
&lt;img alt="第一范式" src="https://upload-images.jianshu.io/upload_images/10175660-7f1d5f71d9be0501.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;但是具体地址到底要不要拆分 还要看具体情形，比如看看将来会不会按国家或者省市进行分类汇总或者排序，如果需要，最好就拆，如果不需要而仅仅起字符串的作用，可以不拆 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Mon, 07 May 2018 19:38:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-07:/mysql/design-rule.html</guid><category>基础</category></item><item><title>实际项目运用之Strategy模式（策略模式）</title><link>/design-pattern/strategy.html</link><description>&lt;h1&gt;1. 策略模式概要&lt;/h1&gt;
&lt;p&gt;策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。
下面就以一个示意性的实现讲解策略模式实例的结构。
&lt;img alt="策略模式" src="https://upload-images.jianshu.io/upload_images/10175660-2d9b5e02ce921d8e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;这个模式涉及到三个角色：&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;环境(Context)角色：&lt;/strong&gt;持有一个Strategy的引用。&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;抽象策略(Strategy)角色：&lt;/strong&gt;这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;具体策略(ConcreteStrategy)角色：&lt;/strong&gt;包装了相关的算法或行为。&lt;/p&gt;
&lt;h3&gt;1.1 案例代码&lt;/h3&gt;
&lt;p&gt;策略模式上下文&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class Context {
    //持有一个具体策略的对象
    private Strategy strategy;
    /**
     * 构造函数，传入一个具体策略对象
     * @param strategy    具体策略对象
     */
    public Context(Strategy strategy){
        this.strategy …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sun, 06 May 2018 17:20:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-06:/design-pattern/strategy.html</guid><category>行为型</category></item><item><title>volatile关键字原理实现及应用</title><link>/concurrent/volatile-feature.html</link><description>&lt;h1&gt;1.并发编程中的三个概念&lt;/h1&gt;
&lt;p&gt;在并发编程中, 需要了解线程的三个概念：原子性，可见性，有序性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.原子性&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个很经典的例子就是银行账户转账问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。

试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，
再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。

所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样地反映到并发编程中会出现什么结果呢？&lt;/p&gt;
&lt;p&gt;举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;i = 9;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。
那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2.可见性 …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Fri, 04 May 2018 22:46:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-04:/concurrent/volatile-feature.html</guid><category>基础</category></item><item><title>MYSQL高级特性之【Event事件】</title><link>/mysql/high-event.html</link><description>&lt;p&gt;&lt;strong&gt;一、基本概念&lt;/strong&gt; mysql5.1版本开始引进event概念。event既“时间触发器”，与triggers的事件触发不同，event类似与linux crontab计划任务，用于时间触发。通过单独或调用存储过程使用，在某一特定的时间点，触发相关的SQL语句或存储过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、适用范围&lt;/strong&gt; 对于每隔一段时间就有固定需求的操作，如创建表，删除数据等操作，可以使用event来处理。&lt;/p&gt;
&lt;p&gt;例如：使用event在每月的1日凌晨1点自动创建下个月需要使用的三张表。&lt;/p&gt;
&lt;p&gt;每天清除数据表中的过期的记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、使用权限&lt;/strong&gt; 单独使用event调用SQL语句时，查看和创建需要用户具有event权限，调用该SQL语句时，需要用户具有执行该SQL的权限。Event权限的设置保存在mysql.user表和mysql.db表的Event_priv字段中。&lt;/p&gt;
&lt;p&gt;当event和procedure（存储过程）配合使用的时候，查看和创建存储过程需要用户具有create routine权限，调用存储过程执行时需要使用excute权限，存储过程调用具体的SQL语句时，需要用户具有执行该SQL的权限。
查看EVENT命令有如下几种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）查询mysql.event表；
（2）通过SHOW EVENTS命令；
（3）通过SHOW FULL EVENTS命令 …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sat, 28 Apr 2018 20:18:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-04-28:/mysql/high-event.html</guid><category>基础</category></item><item><title>MYSQL高级特性之【存储过程与函数】</title><link>/mysql/process-fun.html</link><description>&lt;h1&gt;一、定义&lt;/h1&gt;
&lt;p&gt;存储程序可以分为存储过程和函数。&lt;/p&gt;
&lt;h2&gt;1.1 存储过程的定义&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;存储过程（Stored Procedure）&lt;/strong&gt;是一组为了完成特定功能的SQL语句集。存储过程在数据库中经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。&lt;/p&gt;
&lt;h2&gt;1.2 函数的定义&lt;/h2&gt;
&lt;p&gt;存储函数（简称&lt;strong&gt;函数&lt;/strong&gt;）在本质上与存储过程没有区别。&lt;/p&gt;
&lt;p&gt;只是函数有如：只能返回一个变量的限制，而存储过程可以返回多个。函数是可以嵌入在SQL中使用，可以在select中调用，而存储过程不行。&lt;/p&gt;
&lt;h1&gt;二、创建存储过程和函数&lt;/h1&gt;
&lt;p&gt;存储过程和函数的创建过程很相似。&lt;/p&gt;
&lt;h2&gt;2.1 创建存储过程&lt;/h2&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CREATE PROCEDURE sp_name ([ proc_parameter ]) [ characteristics..] routine_body &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;proc_parameter指定存储过程的参数列表，列表形式如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[IN|OUT|INOUT] param_name type&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中in表示输入参数，out表示输出参数，inout表示既可以输入也可以输出 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Fri, 27 Apr 2018 22:30:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-04-27:/mysql/process-fun.html</guid><category>基础</category></item><item><title>分布式之【CAP理论、BASE理论 、FLP不可能定理】</title><link>/distrubuted/cap-base-flp.html</link><description>&lt;h1&gt;1.分布式系统的CAP理论&lt;/h1&gt;
&lt;h2&gt;1.1 CAP理论概述&lt;/h2&gt;
&lt;p&gt;2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。&lt;/p&gt;
&lt;p&gt;一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cap" src="https://upload-images.jianshu.io/upload_images/10175660-8db37e21ea4984f9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;h2&gt;1.2 CAP的定义&lt;/h2&gt;
&lt;h3&gt;1.2.1 Consistency 一致性&lt;/h3&gt;
&lt;p&gt;一致性指“&lt;code&gt;all nodes see the same data at the same time&lt;/code&gt;”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。分布式的一致性&lt;/p&gt;
&lt;p&gt;对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Wed, 25 Apr 2018 18:43:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-04-25:/distrubuted/cap-base-flp.html</guid><category>理论</category></item><item><title>字符串拼接的疑惑</title><link>/java-base/string-builder-question.html</link><description>&lt;p&gt;最近没事在玩ASM框架，于是乎想将业务代码中的PO对象中的toString方法 在编译期间，自动转换了基于StringBuilder 拼接的代码。发现了一个奇怪的问题：
实体类如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@Getter
@Setter
@EqualsAndHashCode(of = &amp;quot;id&amp;quot;)
@ApiModel(&amp;quot;活动&amp;quot;)
public class Banner implements Serializable{

    private static final long serialVersionUID = 191609922585601269L;

    @ApiModelProperty(value = &amp;quot;ID&amp;quot;, position = 1)
    private Integer id;

    @ApiModelProperty(value = &amp;quot;显示次序&amp;quot;, position = 2)
    private Integer orderNo;

    @ApiModelProperty(value = &amp;quot;关联文件&amp;quot;, position = 3)
    private Integer fileId;

    @ApiModelProperty …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sat, 21 Apr 2018 15:34:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-04-21:/java-base/string-builder-question.html</guid><category>基础</category></item><item><title>Java异常处理-原理及优化建议</title><link>/java-base/exception-introduce.html</link><description>&lt;h1&gt;1 异常层次结构&lt;/h1&gt;
&lt;p&gt;异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。
      Java异常类层次结构图：
&lt;img alt="Java异常类层次结构图" src="https://upload-images.jianshu.io/upload_images/10175660-248cd3eb6352bfb8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。
       &lt;strong&gt;Throwable&lt;/strong&gt;： 有两个重要的子类：&lt;em&gt;Exception（异常）和 Error（错误）&lt;/em&gt;，二者都是 Java 异常处理的重要子类，各自都包含大量子类。
       &lt;strong&gt;Error&lt;/strong&gt;（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Tue, 17 Apr 2018 19:00:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-04-17:/java-base/exception-introduce.html</guid><category>基础</category></item><item><title>java内存模型之[JMM][重排序][happens-before]</title><link>/concurrent/thread-jmm-happens-before.html</link><description>&lt;h1&gt;1.并发编程模型的分类&lt;/h1&gt;
&lt;p&gt;在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同
步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换
信息。在命令式编程中，线程之间的通信机制有两种：&lt;em&gt;共享内存和消息传递&lt;/em&gt;。
在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内
存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状
态，线程之间必须通过明确的发送消息来显式进行通信。
同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模
型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之
间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，
因此同步是隐式进行的。
Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通
信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的
线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。&lt;/p&gt;
&lt;h1&gt;2.Java 内存模型的抽象&lt;/h1&gt;
&lt;p&gt;在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共
享（本文使用“共享变量 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Tue, 03 Apr 2018 22:11:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-04-03:/concurrent/thread-jmm-happens-before.html</guid><category>基础</category></item><item><title>实际项目运用之Decorator模式（装饰器模式）</title><link>/design-pattern/decorator.html</link><description>&lt;h2&gt;1 概述&lt;/h2&gt;
&lt;p&gt;在项目中，经常因一些新增需求，导致同一业务的变更，如果所在类继承关系如下：Parent、Child、Grandparent，那么要在Child类上增强些功能怎么办？给Child类增加方法？那会对Grandparent产生什么影响？该如何去处理？看完本文，你会找到你的答案。&lt;/p&gt;
&lt;p&gt;JavaIO中，像下面的嵌套语句很常见，为什么要怎样定义呢？理解装饰模式后，你会找到答案。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FilterInputStream filterInputStreasm = new BufferedInputStream(new FileInputStream(new File(&amp;quot;/user/a&amp;quot;)));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;1.1案例&lt;/h3&gt;
&lt;p&gt;例如下面一个功能需求，4s店的汽车销售向客户推销自家品牌的产品，我们用代码实现，关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="类图" src="https://upload-images.jianshu.io/upload_images/10175660-789e0242028d08b0.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;具体代码：
汽车销售类&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public abstract class CarSale {

    /**
     * 推销车的详情
     */
    public abstract void displayCarInfo();

    /**
     * 客户签订购买合同
     */
    public abstract …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Wed, 28 Mar 2018 11:22:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-03-28:/design-pattern/decorator.html</guid><category>结构型</category></item><item><title>接口设计的幂等性考虑</title><link>/distrubuted/interface-idempotency.html</link><description>&lt;h2&gt;分布式系统接口幂等性&lt;/h2&gt;
&lt;h3&gt;1.幂等性定义&lt;/h3&gt;
&lt;h4&gt;1.1 数学定义&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在数学里，幂等有两种主要的定义：- 在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。即 s *s = s- 某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x)) = f(x)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;1.2 HTTP规范的定义&lt;/h4&gt;
&lt;p&gt;在HTTP/1.1规范中幂等性的定义是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A request method is considered "idempotent" if the intended effect on the server of multiple identical requests …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Mon, 26 Mar 2018 18:49:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-03-26:/distrubuted/interface-idempotency.html</guid><category>理论</category></item><item><title>java中位运算技巧</title><link>/java-base/binary-operation.html</link><description>&lt;p&gt;位运算符主要针对二进制，它包括了：“与”、“非”、“或”、“异或”。&lt;/p&gt;
&lt;h2&gt;运算符 含义 描述&lt;/h2&gt;
&lt;p&gt;【&amp;amp;】 按位与 如果两个相应的二进制位都为1，则该位的结果值为1，否则为0
【|】按位或 两个相应的二进制位中只要有一个为1，该位的结果值为1
【^】 按位异或 若参加运算的两个二进制位值相同则为0，否则为1
【~】 取反 ~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0
【&amp;lt;&amp;lt;】 左移 用来将一个数的各二进制位全部左移N位，右补0
【&amp;gt;&amp;gt;】右移 将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0&lt;/p&gt;
&lt;h4&gt;1、“按位与”运算符（&amp;amp;）&lt;/h4&gt;
&lt;p&gt;按位与是指：参加运算的两个数据，按二进制位进行“与”运算。如果两个相应的二进制位都为１，则该位的结果值为1；否则为0。内存储存数据的基本单位是字节（Byte），一个字节由8个位（bit)所组成。位是用以描述电脑数据量的最小单位。二进制系统中 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Wed, 21 Mar 2018 22:17:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-03-21:/java-base/binary-operation.html</guid><category>基础</category></item><item><title>ClassLoader类加载分析（二）</title><link>/classloader/classloader-chapter02.html</link><description>&lt;h1&gt;一、JVM 提供的 Classloader&lt;/h1&gt;
&lt;h2&gt;1.1 BootstrapClassloader&lt;/h2&gt;
&lt;p&gt;引导类加载器，又称启动类加载器，是最顶层的类加载器，主要用来加载Java核心类，如rt.jar、resources.jar、charsets.jar等，Sun的JVM中，执行java的命令中使用&lt;strong&gt;-Xbootclasspath选项或使用- D选项&lt;/strong&gt;指定sun.boot.class.path系统属性值可以指定附加的类，它不是 java.lang.ClassLoader的子类，而是由JVM自身实现的该类c 语言实现，Java程序访问不到该加载器。通过下面代码可以查看该加载器加载了哪些jar包&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;class&lt;/span&gt; &lt;span class="nt"&gt;MainClass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="err"&gt;public&lt;/span&gt; &lt;span class="err"&gt;static&lt;/span&gt; &lt;span class="err"&gt;void&lt;/span&gt; &lt;span class="err"&gt;main(String&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt; &lt;span class="err"&gt;args)&lt;/span&gt; &lt;span class="err"&gt;throws&lt;/span&gt; &lt;span class="err"&gt;ClassNotFoundException&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;URL&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt; &lt;span class="err"&gt;urls&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;sun.misc.Launcher.getBootstrapClassPath …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Tue, 20 Mar 2018 22:48:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-03-20:/classloader/classloader-chapter02.html</guid><category>源码</category></item><item><title>Java 内省(Introspector)</title><link>/java-base/introspector.html</link><description>&lt;p&gt;&lt;strong&gt;内省(Introspector) 是Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。&lt;/p&gt;
&lt;p&gt;例如类Use :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class User {

    private String name;

    private String address;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddress …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Tue, 13 Mar 2018 15:15:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-03-13:/java-base/introspector.html</guid><category>基础</category></item><item><title>ClassLoader类加载分析（一）</title><link>/classloader/classloader-chapter01.html</link><description>&lt;h1&gt;一、什么是Classloader&lt;/h1&gt;
&lt;p&gt;一个Java程序要想运行起来，首先需要经过编译生成 .class文件，然后创建一个运行环境（jvm）来加载字节码文件到内存运行，而.class 文件是怎样被加载中jvm 中的就是Java Classloader所做的事情。
&lt;img alt="class文件执行过程" src="http://upload-images.jianshu.io/upload_images/10175660-fc4f3b0b39421a8b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;那么.class文件什么时候会被类加载器加载到jvm中运行那？比如执行new操作时候，当我们使用Class.forName(“包路径+类名”)，Class.forName(“包路径+类名”,classloader),classloader.loadclass(“包路径+类名”);时候就触发了类加载器去类加载对应的路径去查找*.class,并创建Class对象。&lt;/p&gt;
&lt;h1&gt;类的加载过程&lt;/h1&gt;
&lt;p&gt;类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：&lt;/p&gt;
&lt;p&gt;1、装载&lt;/p&gt;
&lt;p&gt;2-4、链接 -包括 【验证、准备、解析】&lt;/p&gt;
&lt;p&gt;5、初始化&lt;/p&gt;
&lt;p&gt;6、使用&lt;/p&gt;
&lt;p&gt;7、卸载 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Thu, 08 Mar 2018 21:15:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-03-08:/classloader/classloader-chapter01.html</guid><category>源码</category></item><item><title>设计模式之builder模式</title><link>/design-pattern/builder.html</link><description>&lt;p&gt;建造者模式也叫生成器模式，和抽象工厂模式相似，也是一种构建复杂对象的模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建造者模式中的角色分类&lt;/strong&gt;： 
 抽象建造者Builder：接口类型，用于规范各个产品的组成部分； 
 具体建造者ConcreteBuilder：实现Builder中的所有方法，返回一个产品实例； 
 指导者Director：指挥建造者制造相应的产品 
 产品Product：用户最终看到的复杂对象。&lt;/p&gt;
&lt;p&gt;假设我们有一个向客户发送新年祝福邮件的需求，而邮件内容可以是纯文档的，也可以是有动画的，也可以是有音频的，可以动态的添加个组件&lt;/p&gt;
&lt;p&gt;uml下图所示： 
&lt;img alt="建造者模式" src="http://upload-images.jianshu.io/upload_images/10175660-73b74bcbd9ee9ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，邮箱有多个组件，包含收件人，发送人，内容，音乐等 
通过具体的建造者添加不同的组件模版，最后通过指挥者去调用抽象建造者 
来返回具体的email对象&lt;/p&gt;
&lt;p&gt;代码如下
==================product======================&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;interface&lt;/span&gt; &lt;span class="nt"&gt;Module&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="err"&gt;String&lt;/span&gt; &lt;span class="err"&gt;showInfo(String&lt;/span&gt; &lt;span class="err"&gt;info)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;

&lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;abstract&lt;/span&gt; &lt;span class="nt"&gt;class&lt;/span&gt; &lt;span class="nt"&gt;CommonModule&lt;/span&gt; &lt;span class="nt"&gt;implements&lt;/span&gt; &lt;span class="nt"&gt;Module&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="err"&gt;protected&lt;/span&gt; &lt;span class="err"&gt;String&lt;/span&gt; &lt;span class="err"&gt;moduleName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="err"&gt;protected&lt;/span&gt; &lt;span class="err"&gt;String&lt;/span&gt; &lt;span class="err"&gt;productionTime …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Tue, 19 Dec 2017 22:15:00 +0800</pubDate><guid isPermaLink="false">tag:None,2017-12-19:/design-pattern/builder.html</guid><category>创建型</category></item><item><title>设计模式之factory模式</title><link>/design-pattern/builder-factory.html</link><description>&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：工厂模式通俗意义上讲就是一个多产品的流程化工厂，每个工厂生产同一系列相关性的组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分类&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;按工厂职能划分可以分为三类： 
 简单工厂模式（Simple Factory） 
 工厂方法模式（Factory Method） 
 抽象工厂方法（Abstract Factory）&lt;/p&gt;
&lt;p&gt;接下来我们直接通过&lt;strong&gt;uml&lt;/strong&gt;图和具体的代码实现以上三类&lt;/p&gt;
&lt;p&gt;我们以汽车工厂生产汽车为例，本田工厂假设要生产CIVIC和CRV两种车型，那么我们该怎么去设计实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 简单工厂模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="简单工厂模式" src="http://upload-images.jianshu.io/upload_images/10175660-4012e2250133cb61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;工厂产品线流程如上图所示：工厂生产汽车通过指定汽车的编号，我们就可以走指定的产品线；调用者只需要选择具体车型而不需要内部车是怎么制造出来的&lt;/p&gt;
&lt;p&gt;简单工厂模式主要包括三部分： 
工厂角色：上图中的HONDAFactroy 生产车型用 
抽象产品角色：上图中的HONDA和HONDACar 包含通用的属性和方法 
具体产品角色：上图中的CIVIC和CRV，具体的车型包含各种参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;* @author nicky_chin [shuilianpiying@163.com] &lt;/span&gt;
&lt;span class="cm"&gt;* @since –created on 2017/12/27 at 11 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Thu, 07 Dec 2017 22:30:00 +0800</pubDate><guid isPermaLink="false">tag:None,2017-12-07:/design-pattern/builder-factory.html</guid><category>创建型</category></item><item><title>多线程之线程通信摘要</title><link>/concurrent/thread-communication.html</link><description>&lt;p&gt;首先我们要知道进程之间的通讯方式有哪些？&lt;/p&gt;
&lt;h1&gt;管道( pipe )  #消息队列( message queue ) #共享内存( shared memory ) ：#套接字( socket ) 等等--&lt;/h1&gt;
&lt;p&gt;线程的通讯方式：&lt;/p&gt;
&lt;p&gt;1 wait/notify 机制&lt;/p&gt;
&lt;p&gt;wait()方法和notify()方法是Object类提供的方法，而在使用的条件就是当前线程必须有自己的监听器&lt;/p&gt;
&lt;p&gt;否则就是抛出异常，我们可以使用jvm提供的内置锁 synchronized 关键字来配合使用；注意如果有多个&lt;/p&gt;
&lt;p&gt;线程等待，当某一线程发起唤醒操作，会随机唤醒一个线程，而非所有线程，如果想唤醒所有线程，可以使用&lt;/p&gt;
&lt;p&gt;notifyAll()方法&lt;/p&gt;
&lt;p&gt;下面是 启动一个等待线程和一个通知线程的例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class MyThread1 extends Thread {  

    private Object lock;  

    public MyThread1(Object lock) {  
        this.lock …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sat, 18 Nov 2017 21:52:00 +0800</pubDate><guid isPermaLink="false">tag:None,2017-11-18:/concurrent/thread-communication.html</guid><category>基础</category></item><item><title>可重入锁</title><link>/concurrent/recursive-Lock.html</link><description>&lt;p&gt;可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。比如ReentrantLock 和synchronized 都是 可重入锁&lt;/p&gt;
&lt;p&gt;直接放代码 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class SubService {

ReentrantLock lock = new ReentrantLock();

public void subService1() {

    lock.lock();

    System.out.println(&amp;quot;thread = &amp;quot; + Thread.currentThread().getId() + &amp;quot; --subService1&amp;quot;);

    subService2();

    lock.unlock();

}

public synchronized void subService2() {

    System.out.println(&amp;quot;thread = &amp;quot; + Thread.currentThread().getId() + &amp;quot; --subService2&amp;quot;);

}

}

public class Service extends …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Fri, 03 Nov 2017 21:22:00 +0800</pubDate><guid isPermaLink="false">tag:None,2017-11-03:/concurrent/recursive-Lock.html</guid><category>基础</category></item></channel></rss>