<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>南乡清水 - design-pattern</title><link>/</link><description></description><lastBuildDate>Fri, 29 Jun 2018 22:18:00 +0800</lastBuildDate><item><title>实际项目运用之Responsibility-Chain模式（责任链模式）</title><link>/design-pattern/responsibility-chain.html</link><description>&lt;h1&gt;1 模式概要&lt;/h1&gt;
&lt;h3&gt;1.1 简介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;责任链模式为请求创建一个接收者对象链，每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把请求传给下一个接收者，依此类推&lt;/li&gt;
&lt;li&gt;责任链模式避免了请求的发送者和接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连成一条链，并且沿着这条链传递请求，直到有对象处理它为止&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.2 责任链模式优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;降低耦合度。它将请求的发送者和接收者解耦
简化了对象，使得对象不需要知道链的结构
增强给对象指派职责的灵活性，允许动态地新增或者删除责任链
增加新的请求处理类方便&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不能保证请求一定被接收；
系统性能将受到一定影响，调试时不方便，可能会造成循环调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;2 模式结构&lt;/h1&gt;
&lt;h3&gt;2.1 对象定义&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Handler（抽象处理者）&lt;/em&gt;： 定义一个处理请求的接口，提供对后续处理者的引用
&lt;em&gt;ConcreteHandler（具体处理者）&lt;/em&gt;： 抽象处理者的子类，处理用户请求，可选将请求处理掉还是传给下家；在具体处理者中可以访问链中下一个对象，以便请求的转发&lt;/p&gt;
&lt;h3&gt;2.2 类图及设计 …&lt;/h3&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Fri, 29 Jun 2018 22:18:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-06-29:/design-pattern/responsibility-chain.html</guid><category>行为型</category></item><item><title>设计模式之单例模式终极版【克隆-序列化-反射】</title><link>/design-pattern/singletion.html</link><description>&lt;h1&gt;1 基本内容&lt;/h1&gt;
&lt;h3&gt;1.1 概念&lt;/h3&gt;
&lt;p&gt;单例模式，是指在任何时候，该类只能被实例化一次，在任何时候，访问该类的对象，对象都是同一个。只要是程序员都会使用到，甚至都不能算是设计模式。但是在我们使用中也需要了解一下单例特性和使用场景&lt;/p&gt;
&lt;h3&gt;1.2 模式优缺点&lt;/h3&gt;
&lt;p&gt;单例模式有以下优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用单例模式可以严格的控制用户怎样以及如何访问它
节约系统资源，提高系统的性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单例模式有以下缺点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不易扩展
单例类职责过重，在一定程度上违背了“单一职责原则”
如实例化对象长时间未使用，会GC回收，导致对象状态的丢失&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#2 单例模式分类&lt;/p&gt;
&lt;h3&gt;2.1 饿汉模式&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SingletonEHan&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;SingletonEHan&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;

    &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * 1.单例模式的饿汉式&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;SingletonEHan&lt;/span&gt; &lt;span class="n"&gt;singletonEHan&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SingletonEHan&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;SingletonEHan …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Thu, 07 Jun 2018 22:15:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-06-07:/design-pattern/singletion.html</guid><category>创建型</category></item><item><title>实际项目运用之Adapter模式（适配器模式）</title><link>/design-pattern/adapter.html</link><description>&lt;h1&gt;1. 模式简介&lt;/h1&gt;
&lt;p&gt;适配器模式解决的问题：让原本因为接口不兼容而不能一起工作的类可以一起工作&lt;/p&gt;
&lt;p&gt;适配器模式中有三种角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标接口Target：用户期望的类，可以是接口，也可以是抽象类或具体类；&lt;/li&gt;
&lt;li&gt;需要适配的类Adaptee：当前系统中有的类；&lt;/li&gt;
&lt;li&gt;适配器Adapter：在现有接口和目标接口之间的“适配者”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;适配器模式的优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过适配器模式，用户在做相似的操作时可以调用同一个接口，其内部过程对于用户是透明的，这样做更简单、更直接、更解耦；
复用了现存的类，解决了现存类和复用环境要求不一致的问题；
将目标接口和现有接口解耦，通过引入一个适配器类，而无需修改原有的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;适配器模式的缺点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用适配器模式后，如果想要改变适配对象，就需要更换适配器，而更换适配器是一个非常复杂的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;适配器模式的适用场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当系统需要使用现有的类，而现有的类不符合系统的接口
 当期望的功能和系统中现有的某个类的功能相似，但是具有不同的接口
当系统已经实现某功能，但用户想通过另种接口方式访问，而不想修改原有接口
当使用的第三方组件的接口和系统中定义好的接口不同，不希望修改系统接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;2.案例代码&lt;/h1&gt;
&lt;p&gt;适配器分类_适配器模式_和_对象适配器模式_&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 类适配器UML&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="类适配器类图" src="https://upload-images.jianshu.io/upload_images/10175660-d80f54d37ebaa675.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 对象适配器模式UML …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sun, 27 May 2018 23:15:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-27:/design-pattern/adapter.html</guid><category>结构型</category></item><item><title>设计模式之Template模式（模版模式）</title><link>/design-pattern/template.html</link><description>&lt;h1&gt;1 模式简介&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1.1 模版方法模式的定义：&lt;/strong&gt;
模版方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 结构&lt;/strong&gt;
&lt;img alt="模版方法" src="https://upload-images.jianshu.io/upload_images/10175660-4b852101cc35ec28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3 模式的组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;抽象类（AbstractClass）:&lt;/em&gt;&lt;/strong&gt; 定义抽象的原语操作（primitive operation） ，具体的子类将重定义它们以实现一个算法， 实现一个模板方法,定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义。
&lt;strong&gt;&lt;em&gt;具体子类 （ConcreteClass）:&lt;/em&gt;&lt;/strong&gt; 实现原语操作以完成算法中与特定子类相关的步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.4 优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模版方法模式的优点：
   封装不变部分，扩展可变部分；
   提取公共代码，便于维护；
   行为由父类控制，子类实现。&lt;/p&gt;
&lt;p&gt;模版方法模式的缺点：
   每一个不同的实现都需要一个子类来实现，导致类个数增加，使系统更加庞大&lt;/p&gt;
&lt;p&gt;模版方法模式的适用场景：
   当类中有多个子类共有的方法
   当有重要的、复杂的方法时，可以考虑作为模板方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;2 案例&lt;/h1&gt;
&lt;p&gt;抽象类 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Fri, 18 May 2018 21:46:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-18:/design-pattern/template.html</guid><category>行为型</category></item><item><title>实际项目运用之Strategy模式（策略模式）</title><link>/design-pattern/strategy.html</link><description>&lt;h1&gt;1. 策略模式概要&lt;/h1&gt;
&lt;p&gt;策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。
下面就以一个示意性的实现讲解策略模式实例的结构。
&lt;img alt="策略模式" src="https://upload-images.jianshu.io/upload_images/10175660-2d9b5e02ce921d8e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;这个模式涉及到三个角色：&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;环境(Context)角色：&lt;/strong&gt;持有一个Strategy的引用。&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;抽象策略(Strategy)角色：&lt;/strong&gt;这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;具体策略(ConcreteStrategy)角色：&lt;/strong&gt;包装了相关的算法或行为。&lt;/p&gt;
&lt;h3&gt;1.1 案例代码&lt;/h3&gt;
&lt;p&gt;策略模式上下文&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class Context {
    //持有一个具体策略的对象
    private Strategy strategy;
    /**
     * 构造函数，传入一个具体策略对象
     * @param strategy    具体策略对象
     */
    public Context(Strategy strategy){
        this.strategy …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Sun, 06 May 2018 17:20:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-05-06:/design-pattern/strategy.html</guid><category>行为型</category></item><item><title>实际项目运用之Decorator模式（装饰器模式）</title><link>/design-pattern/decorator.html</link><description>&lt;h2&gt;1 概述&lt;/h2&gt;
&lt;p&gt;在项目中，经常因一些新增需求，导致同一业务的变更，如果所在类继承关系如下：Parent、Child、Grandparent，那么要在Child类上增强些功能怎么办？给Child类增加方法？那会对Grandparent产生什么影响？该如何去处理？看完本文，你会找到你的答案。&lt;/p&gt;
&lt;p&gt;JavaIO中，像下面的嵌套语句很常见，为什么要怎样定义呢？理解装饰模式后，你会找到答案。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FilterInputStream filterInputStreasm = new BufferedInputStream(new FileInputStream(new File(&amp;quot;/user/a&amp;quot;)));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;1.1案例&lt;/h3&gt;
&lt;p&gt;例如下面一个功能需求，4s店的汽车销售向客户推销自家品牌的产品，我们用代码实现，关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="类图" src="https://upload-images.jianshu.io/upload_images/10175660-789e0242028d08b0.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;具体代码：
汽车销售类&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public abstract class CarSale {

    /**
     * 推销车的详情
     */
    public abstract void displayCarInfo();

    /**
     * 客户签订购买合同
     */
    public abstract …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Wed, 28 Mar 2018 11:22:00 +0800</pubDate><guid isPermaLink="false">tag:None,2018-03-28:/design-pattern/decorator.html</guid><category>结构型</category></item><item><title>设计模式之builder模式</title><link>/design-pattern/builder.html</link><description>&lt;p&gt;建造者模式也叫生成器模式，和抽象工厂模式相似，也是一种构建复杂对象的模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建造者模式中的角色分类&lt;/strong&gt;： 
 抽象建造者Builder：接口类型，用于规范各个产品的组成部分； 
 具体建造者ConcreteBuilder：实现Builder中的所有方法，返回一个产品实例； 
 指导者Director：指挥建造者制造相应的产品 
 产品Product：用户最终看到的复杂对象。&lt;/p&gt;
&lt;p&gt;假设我们有一个向客户发送新年祝福邮件的需求，而邮件内容可以是纯文档的，也可以是有动画的，也可以是有音频的，可以动态的添加个组件&lt;/p&gt;
&lt;p&gt;uml下图所示： 
&lt;img alt="建造者模式" src="http://upload-images.jianshu.io/upload_images/10175660-73b74bcbd9ee9ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，邮箱有多个组件，包含收件人，发送人，内容，音乐等 
通过具体的建造者添加不同的组件模版，最后通过指挥者去调用抽象建造者 
来返回具体的email对象&lt;/p&gt;
&lt;p&gt;代码如下
==================product======================&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;interface&lt;/span&gt; &lt;span class="nt"&gt;Module&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="err"&gt;String&lt;/span&gt; &lt;span class="err"&gt;showInfo(String&lt;/span&gt; &lt;span class="err"&gt;info)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;

&lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;abstract&lt;/span&gt; &lt;span class="nt"&gt;class&lt;/span&gt; &lt;span class="nt"&gt;CommonModule&lt;/span&gt; &lt;span class="nt"&gt;implements&lt;/span&gt; &lt;span class="nt"&gt;Module&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="err"&gt;protected&lt;/span&gt; &lt;span class="err"&gt;String&lt;/span&gt; &lt;span class="err"&gt;moduleName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="err"&gt;protected&lt;/span&gt; &lt;span class="err"&gt;String&lt;/span&gt; &lt;span class="err"&gt;productionTime …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Tue, 19 Dec 2017 22:15:00 +0800</pubDate><guid isPermaLink="false">tag:None,2017-12-19:/design-pattern/builder.html</guid><category>创建型</category></item><item><title>设计模式之factory模式</title><link>/design-pattern/builder-factory.html</link><description>&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：工厂模式通俗意义上讲就是一个多产品的流程化工厂，每个工厂生产同一系列相关性的组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分类&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;按工厂职能划分可以分为三类： 
 简单工厂模式（Simple Factory） 
 工厂方法模式（Factory Method） 
 抽象工厂方法（Abstract Factory）&lt;/p&gt;
&lt;p&gt;接下来我们直接通过&lt;strong&gt;uml&lt;/strong&gt;图和具体的代码实现以上三类&lt;/p&gt;
&lt;p&gt;我们以汽车工厂生产汽车为例，本田工厂假设要生产CIVIC和CRV两种车型，那么我们该怎么去设计实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 简单工厂模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="简单工厂模式" src="http://upload-images.jianshu.io/upload_images/10175660-4012e2250133cb61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"&gt;&lt;/p&gt;
&lt;p&gt;工厂产品线流程如上图所示：工厂生产汽车通过指定汽车的编号，我们就可以走指定的产品线；调用者只需要选择具体车型而不需要内部车是怎么制造出来的&lt;/p&gt;
&lt;p&gt;简单工厂模式主要包括三部分： 
工厂角色：上图中的HONDAFactroy 生产车型用 
抽象产品角色：上图中的HONDA和HONDACar 包含通用的属性和方法 
具体产品角色：上图中的CIVIC和CRV，具体的车型包含各种参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;* @author nicky_chin [shuilianpiying@163.com] &lt;/span&gt;
&lt;span class="cm"&gt;* @since –created on 2017/12/27 at 11 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">nicky_chin</dc:creator><pubDate>Thu, 07 Dec 2017 22:30:00 +0800</pubDate><guid isPermaLink="false">tag:None,2017-12-07:/design-pattern/builder-factory.html</guid><category>创建型</category></item></channel></rss>